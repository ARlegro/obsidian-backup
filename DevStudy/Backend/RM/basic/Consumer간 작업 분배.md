
메시지를 여러 Consumer간에 분배하여 작업을 분산 처리하는 구조 
작업 부하를 효율적으로 분산하고, 병렬 처리를 가능하게 만들어 처리 속도를 향상시킨다.
이를 위한 방법으로 아래와 같은 방법들이 있다.
1. **Round-Robin 방식** (Default)
2. **Fair Dispatch 방식** : 메시지 수동 확인모드로 개발하는 것. 이건 개발자가 할 일은 많이 없다.(보통은 그냥 수동보다는 Default값인 AUTO를 많이 씀)


>[!EXAMPLE] Round-Robin 방식
> > 큐에 들어오는 **메시지를** 연결된 Consumer들에게 **순서대로 하나씩 공평하게 분배**하는 방식
>- **특징**  💚
>	- 공평한 분배 : 작업 부하 균등하게 분산 가능 
>	- 구현 단순성 : Auto로 설정되어 있음
>	- 병렬 처리 
>	- 확장성 : 단순히 Consumer 인스턴스 추가하면 쉽게 시스템 확장 가능
>- **한계 💢**
>	- 공평하지 않을 수 있다 : 각 Consumer가 받는 메시지의 길이가 다를 수 있기에 개수는 같더라도 공평하지 않을 수 있다.




### 작업 분배 특징 
1. **경쟁적인 메시지 소비**
	- 여러 Consumer가 동일한 메시지 큐에서 메시지를 가져가 처리한다.
	- 특정 메시지는 한번에 하나의 Consumer에 의해 처리되므로 메시지 중복 처리 간으 
	  
2. **작업 분산**
	- 병렬로 처리되므로 작업 부하 효율적 
3. **확장성**
	- 작업 처리 능력을 Consumer 추가 및 삭제로 동적 조절 가능하다.
	  
4. **내결함성**
	- Consumer 중 하나가 실패하더라도 다른 Consumer가 작업을 이어받아 처리 가능 ➡ 시스템 중단 없이 작동 가능 





### 재처리 방법 

acknowledgeMode가 Auto(디폴트)로 되어있을 때 가능 

일단 R.M admin 서버 -> Queue를 확인하면 아래와 같은 화면이 나올 것. 
![[Pasted image 20250615132127.png]]
**Ready**
- **대기중인 메시지들** 
- **강제 삭제 방법** : purge 명령 ➡ 큐에 있는 Ready 메시지를 삭제 
- 삭제된 메시지는 복구되지 않는다.
- **많을 경우 문제**가 된다.
	- 해결 1. Consumer 수 늘리기
	- 해결 2. Consumer의 메시지 처리 속도 늘리기 


**Unacked** 
- 메시지가 **Consumer에게 전달되었으나 아직 확인되지 않은 상태** 
- Consumer가 ACK(확인)을 보내면 R.M은 해당 메시지를 삭제 
- Consumer가 ACK(확인)을 보내지 못하거나 연결이 끊어지면, 메시지는 Ready상태로 돌아감(물론 설정에 따라 다름)
- **삭제 방법** : Consumer 연결 종료 or R.M 재시작 
- **많을 경우 문제** 발생 
	- 해결 1. Consumer 코드 수중 (프로그램 에러 가능성 높음)
	- 해결 2. 재연결 or 재싲가 




