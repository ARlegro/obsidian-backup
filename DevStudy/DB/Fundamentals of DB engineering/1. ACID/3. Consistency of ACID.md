> Consistency = 일관성 

몇몇 DB는 성능을 위해 일관성을 포기하기도 한다.


Consistency는 2가지 종류가 있다.
1. Consistency in Data
2. Consistency in Reads 

Data가 일관성이 있어도 Read시 일관성이 없을 수 있다.

### 1. Consistency in Data (데이터의 일관성) 
- **User에 의해 정의**된다. ex. DBA, 개발자
- 대부분은 **참조 무결성을 지킨다.**
	- RDBMS에서는 FK를 통해 테이블간 참조 관계가 항상 유효함을 보장 
	- 가령, FK는 있는데 FK에 해당하는 cardinality or 테이블이 없다면 그것은 참조 무결성 어긴 것 
- **원자성 必**
	- 트랜잭션이 원자적으로 실행되어야 Data의 Consistency가 유지된다.
- 격리 수준에 따라 다른 일관성 결과가 나타날 수 있다.

### 2. Consistency in Read (읽기에서의 일관성)

>[!tip] COMMIT한 데이터를 즉시 읽을 수 있는가 ➡ 가능하면 읽기 일관성 있는 것 
#### Concept 
- 데이터를 업데이트한 후 새로운 트랜잭션이 **즉시** 변경된 값을 읽을 수 있는가에 대한 것
- Data는 일관되게 저장되어 있더라도, **읽기 시점에 불일치가 발생**할 수 있다.
- 시스템 전체에서 발생하는 일관성 문제.
- 주로 분산 시스템에서 발생 
	- shard, partition, replica를 가진 분산 데이터베이스 시스템에서 주로 발생한다.

#### Example
![[Pasted image 20250602162930.png]]
❓트랜잭션이 어떤 값을 커밋한 후, 새로운 트랜잭션이 그 값을 즉시 볼 수 있는가❓
- 만약, 그렇지 않다면 그것은 InConsistency in Read 문제가 발생한 것이다.


#### 불일치 예시 in 분산 시스템 
> 읽기 불일치는 주로 데이터베이스 복제(Replication) 환경에서 발생한다.

다음과 같은 상황에서 발생: 
1. 데이터를 주 데이터베이스(Primary)에 적용
2. 주 데이터베이스는 이 변경 사항을 **복제본 데이터베이스(Replicas)로 동기화**
3. 이때, 만약 사용자가 **복제본에서 데이터를 읽으려고 한다면**, 변경 사항이 복제본으로 완전히 동기화되기 전까지는 **오래된(old) 값**을 읽게 될 수 있다.
4. 이것이 바로 **읽기에서의 불일치**. 


#### 결과적 일관성(Eventual Consistency)
> "지금 당장은 일관되지 않더라도, **결국에는(eventually)** 일관된 상태가 될 것이다"라는 의미
- 주로 읽기에서의 일관성에 적용 
- 사용자가 계속 READ요청을 보내면 결국에는 최신값을 얻는거니 결과적으로 일관적이라는 뜻 
- 한계 
	- 데이터 자체가 망가지거나, 참조 무결성이 해쳐지는 것은 결과적 일관성으로도 되지 않는다.

Deep Note : [[Eventually Consistency]]
#### 일관성의 강도: 강력한 일관성 vs. 결과적 일관성
1. **동기식 복제**(Synchronous Replication): 
	- 쓰기 작업이 마스터와 모든 복제본에 성공적으로 적용될 때까지 기다린다.
	- 이는 **강력한 일관성(Strong Consistency)을 보장**하지만, 복제본의 응답을 기다려야 하므로 **속도가 느립니다.**
	  <BR>
2. **비동기식 복제**(Asynchronous Replication): 
	- 쓰기 작업이 **마스터에 적용되면 즉시 응답**하고,
	- 복제는 백그라운드에서 비동기적으로 진행. 
	- **빠르지만**, 복제 지연으로 인해 **결과적 일관성(Eventual Consistency)**을 가집니다.

[[4. Durability of ACID]]