
### Concept 

- A **collection of SQL queries** that are treated as **one unit** of work.
	 (하나 이상의 SQL 쿼리들이 하나의 논리적 작업 단위로 묶인 것)
- ❓왜 하나의 단위로 묶는가❓
	- 실무에서 대부분의 작업은 단일 쿼리로 끝나지 않는다.
	- 대부분 원하는 work는 여러 쿼리가 합쳐져서 일어난다.
- 예시
	- 가령, 계좌에 돈을 입금하고 싶을 때, 
	- 일단, **SELECT**를 통해 account를 찾아야 한다.
	- 그 다음, **UPDATE**를 통해 해당 account의 잔고를 늘린다.
	- 그 다음, **UPDATE**를 통해 DEPOSIT에 쓰인 다른 account의 잔고를 줄인다.
	- 이 3개의 Queries가 **하나의 트랜잭션**이다.

### Lifespan (수명)

#### 1. BEGIN 
- Transaciont의 항상 `BEGIN`이라는 키워드로 시작 
- 이는, DB에게 트랜잭션이 시작된다는 걸 indicate하는 것 
	  
#### 2. COMMIT 
- 모든 쿼리가 성공적으로 실행되고 만족스러운 결과가 나왔을 때 `COMMIT` 명령을 사용
- **효과** : 데이터베이스에게 트랜잭션 수명 동안 이루어진 **모든 변경 사항을 디스크에 영구적으로 기록하도록 지시**
	1. **`COMMIT`을 실행하기 전**
		- 트랜잭션 내에서 발생한 모든 변경 사항은 DB에 영구적으로 저장되지 않는다.
	2. **`COMMIT` 실행 후** 
		- 트랜잭션의 Lifespan동안 만들어진 모든 변화를 DB에 영구적으로 반영 
- 아마도, COMMIT에 대해서 궁금한게 많을거다(실제 어떻게 persist되는지)
- commit 후 뒤에서 뭔 일이 일어나는지 아는 것은, 이건 매우 굉장히 중요한 거다.
	  
#### 3. ROLLBACK
- 트랜잭션 도중 문제가 발생하거나 사용자가 변경을 원치 않을 때 `ROLLBACK` 명령을 사용
- **효과** : 트랜잭션 시작 이후 이루어진 모든 변경 사항을 취소하고, 데이터베이스를 트랜잭션 시작 전의 상태로 되돌린다.
- **변경사항을 어떻게 저장하는지에 따라** ROLLBACK **과정이 다르다.**
	1. 변경사항을 각 쿼리 실행 시 disk에 **즉시 반영**하는 방식
		- 모든 변경 사항을 '되돌리는' 추가 작업이 必 💢
	2. 변경사항을 memory에 보관했다가 **`COMMIT`시에** disk에 기록하는 방식
		- 단순히 메모리의 내용을 버리면 됨  ✅
	> 여기서 redo, undo space 개념이 나오는데 이건 나중에 
	

>[!todo] 1~3번까지는 USER에 의해 실행 가능한 것이고 4번은 DB에서 실행하는 것 
>

#### 4. Unexpected Ending  ex. crash(충돌)
> 이 경우에도 ROLLBACK이랑 같은 효과이긴 하다 
> - 서버가 ROLLBACK시킴
> - DB마다 최적화 전략이 다름 

- **Crash**
	- 트랜잭션 중간에 데이터베이스가 예기치 않게 충돌할 수 있다.
	- 이 경우, 데이터베이스는 다시 시작될 때 **충돌 당시 진행 중이던 모든 트랜잭션을 자동으로 롤백**할 수 있도록 설계되어야함 
	- 이는 데이터베이스 구축 시 고려해야할 복잡한 사항임 
- **DB마다 다른 최적화**
	- 각 DB는 트랜잭션 관리 및 충돌 복구 방식에서 **서로 다른 최적화 전략**을 가짐 
	1. Postgres
		- 엄청 자주 `COMMIT` 
		- 장점 : `COMMIT`이 빨라서 `ROLLBACK` 잘 안 일어남. ✅
		- 단점 : 많은 I/O 
	
	2. SQL Server 
		- `COMMIT`속도가 매우 느리다.
		- 장점 : I/O 작업 적음
		- 단점 : `COMMIT` 중 crash 가능성이 높다  💢 


### 읽기 전용 트랜잭션 

>일반적으로, 트랜잭션은 데이터를 Modify하는 데 사용된다고 생각하기 쉽지만, 실제로는 **읽기 전용(Read-Only) 트랜잭션**도 존재한다 (매우 중요 ⭐)

- 단순히 데이터를 읽기만 하는 Transaction을 시작하는 것 
- 데이터 베이스에 읽기 전용 Transaction임을 **알리면** ➡ **데이터베이스가 내부적으로 최적화** 

>[!QUESTION] 왜 필요한가❓
>읽는 도중 데이터가 바뀐다면, 문제인데 이걸 Isolate로 해결?
>이는 격리 수준을 배워야 이해할 수 있는 것 (나중에 ㄱ)


### 예시
- **시나리오**: 계좌 1 (잔액: $1,000)에서 계좌 2 (잔액: $500)로 $100를 이체하는 과정.
- **수행 단계**:
    1. **`BEGIN TRANSACTION`**
    2. `SELECT balance FROM Account WHERE ID = 1;` (잔액이 $1000인지 확인)
    3. 제약조건 : `BALACE > 100` 이체할 금액($100)이 충분한지 확인하는 로직 (애플리케이션 또는 데이터베이스 제약 조건).
        - **데이터 불일치 (Inconsistency)**: 만약 잔액이 음수가 되는 상황을 허용한다면 이는 데이터 불일치 상태를 의미할 수 있습니다.
    4. `UPDATE Account SET Balance = Balance - 100 WHERE ID = 1;` (계좌 1에서 $100 차감)
    5. `UPDATE Account SET Balance = Balance + 100 WHERE ID = 2;` (계좌 2에 $100 입금)
    6. **`COMMIT TRANSACTION`** (두 업데이트가 모두 물리적으로 디스크에 기록됨)


### 묵시적(implicity) 트랜잭션 
- 사용자가 명시적으로 트랜잭션을 시작하지 않더라도, 
- 데이터는 **내부적으로** 각 개별 쿼리(ex. `UPDATE`, `INSERT` 등)에 대해 **묵시적(implicitly)으로 트랜잭션을 시작하고 즉시 커밋**한다.

>[!tip] 즉, 개발자가 의식하든 안 하든 **모든 쿼리는 항상 트랜잭션 내에서 실행**


[[1. Atomicity of ACID]]
[[2. Isolation of ACID]]
[[3. Consistency of ACID]]
[[4. Durability of ACID]]