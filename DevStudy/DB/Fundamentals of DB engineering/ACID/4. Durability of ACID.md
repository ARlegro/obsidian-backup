
Durability = 지속성 


**❓What is Durability** 
>커밋된 트랜잭션의 결과는 비휘발성 저장소(데이터베이스)에 **영구적으로 저장**되어야 한다
- 성공적 `COMMIT` 후에는, 시스템에 어떤 장애가 발생하더라도 `COMMIT`된 변경 사항들은 사라지지 않고 영구적으로 보존되어야 한다.


### 지속성이 깨지는 경우
>당연히 커밋하면  영구저장되야 하는거 아닌가? 당연한 것처럼 느껴지는 것도, 실제로는 아닐 수 있다.

많은 데이터베이스 시스템은 성능과 속도를 위해 지속성을 희생한다.
Durability를 위한 작업은 Disk에 직접 저장하므로 시스템을 느리게 만든다.
그래서 많은 데이터베이스는 이러한 문제를 해결하기 위한 전략이 있다.

### 지속화를 위한 기술 

#### 1. WAL (Write-Ahead Log, 쓰기 전 로그)

**✅개념** 
- **모든 데이터 변경 사항**을 실제 디스크에 반영하기 전에 **먼저 로그에 기록**하는 방식의 트랜잭션 로그 파일
- 이 로그는 트랜잭션 deltas(차이점, 변화된 부분)만을 지속적으로 기록하는 로그 파일 
- **목적** 
	- 데이터 무결성 보장 : 복구 가능
	- 성능 향상 
	- Durability 보장 (+ 원자성)
	  
**☑작동 원리** 
1. 트랜잭션이 변경한 데이터는 메모리 상의 버퍼에 먼저 반영된다(Shared_buffers)
2. **WAL에도 해당 변경 내용이 함께 기록** 되는데, 이때도 먼저 메모리에 적재됨(wal-buffers)
3. **트랜잭션 `COMMIT` 요청 ➡ WAL 버퍼의 해당 로그를 디스크에 Flush** 
4. 반면, 실제 데이터 파일(테이블, 인덱스 등)은 나중에 비동기적으로 업데이트 된다.

>[!QUESTION] 왜 필요한가
>1. **변경된 부분만 빠르게 기록** 
>	- 실제 데이터 테이블(인덱스, B-Tree 등)은 크기가 매우 크다.
>	- 따라서, `COMMIT`될 때마다 이 거대한 크기를 직접 Disk에 업데이트하는 것은 매우 느리다.
>	- 따라서, **변경 사항만 따로 기록해두는게 필요**
>  <br>
>2. **데이터 복구 및 Rebuild 용이** ➡ 데이터 무결성 보장 ⭐⭐
>	- 시스템 충돌이 발생해서 메모리가 날라갔더라도 **WAL을 기반으로 데이터베이스 상태를 쉽게 재구성(rebuild)하거나 복구** 
>	- Using : Disk에 **WAL segment** 파일(pg_wal)
>	- COMMIT 직전에 WAL을 반드시 flush하기 때문에 WAL은 disk에 반영 


이는 PostgreSQL이 많이 활용하는 기술이다.


#### 2. 비동기식 스냅샷 (Asynchronous Snapshots)
- 모든 쓰기 작업을 **일단 메모리에 저장** 
- **백그라운드에서 비동기적으로** 주기적으로 전체 **메모리 내용을 디스크에 스냅샷으로 저장** 
- 장점 : 쓰기 작업이 매우 빠르다
- 단점 : 스냅샷 간격 사이에 시스템 충돌이 발생하면, 메모리에만 있던 최근 변경 사항들이 유실될 위험이 있다.
- Redis같은 In-memory DB에서 이런 방식 구현 


## OS 캐시와 DB의 지속성 

>DB의 지속성 과정에는 OS의 역할이 중요하다 


#### OS 캐시의 문제점 

DB는 OS에게 데이터를 disk에 쓰라고 요청한다. 근데 OS는 실제로 **Disk에 바로 쓰지 않고** 자신이 **관리하는 캐시(OS Cache)에 데이터를 저장**한다 for 성능 향상 

>[!danger] 여기서 문제 발생💢
DB가 OS에게 WAL segment를 disk에 요청하면 OS는 OS Cache에 저장한 뒤 성공알림을 보낸다. 이 상태에서 시스템이 Crash 된다면❓
>- **OS Cache는 휘발성 메모리이므로 시스템 재시작 시 데이터가 유실**된다. 
>- DB는 커밋된걸로 알고 서버에도 그렇게 말했는데, 사실은 **데이터가 영구 저장되지 않아 Durability가 깨진 것** 

#### OS 캐시 우회 : fsync 명령 
앞서 말한 OS 캐시의 문제를 해결하고 강력한 Durability를 보장하기 위해 DB 시스템은 OS 캐시를 우회하는 방법이 있다.
- **`fsync`** - 완전한 지속성 (Strongly Durable)
	- OS에게 **변경 사항들을 즉시 Disk에 Flush하라고 강제하는 것** 
	- 이렇게 되면, OS 캐시를 거치지 않고 물리 디스크에 데이터를 바로 씀 
- **장단점**
	- 장점 : 데이터의 강력한 지속성 보장. 시스템 충돌에도 데이터 유실되지 않는다.
	- 단점 : OS Cache를 포기하므로 매우 느려진다.

> 근데, 대부분은 시스템 충돌이 드믈기 때문에, 작은 데이터 손실 위험을 감주하고 빠른 쓰기 속도를 선택하는 경우도 많다.


### 지속성 결론 

**트랜잭션이 커밋된 순간**, 그 변경 사항은 **디스크(SSD, HDD 등)에 영구적으로 보존**되어야한다.
중요한 것은 데이터가 사라지지 않는 것 
