
## 들어가기 앞서 : 일관성 
❓Consistency (일관성)❓

### 두 가지 유형의 일관성: 데이터 일관성 vs. 읽기 일관성

일관성은 두 가지 유형으로 나눌 수 있다.
1. **데이터 일관성 (Consistency in the Data)**
2. **읽기 일관성 (Consistency during Reads)**
---

### 1. 데이터 일관성 (Consistency in the Data)


#### Concept
데이터 일관성은 주로 **데이터 자체의 논리적인 유효성 및 정합성**을 의미
이는 여러 테이블, FK, 조인(Joins) 등을 통해 데이터가 여러 뷰(Views)와 표현 방식으로 존재할 때 중요하게 부각된다.
- **정의**: 사용자가 정의한 규칙과 제약 조건에 따라 데이터가 항상 유효하고 모순이 없음을 보장하는 것
- **예시 (인스타그램)**:
    - `Pictures` 테이블: `ID`, `Blob` (사진 데이터), `total_number_of_likes`
    - `Users_Who_Liked_Pictures` 테이블: 특정 사진을 좋아요 한 사용자 목록
    - **일관성 요구 사항**: 만약 `Pictures` 테이블의 사진 1이 `total_number_of_likes`로 2를 기록했다면, `Users_Who_Liked_Pictures` 테이블에는 사진 1에 대한 좋아요 기록이 **두 개** 존재해야 합니다.

#### 일관성 보장 메커니즘 

- **사용자 정의**
	- 데이터의 일관성은 주로 데이터베이스를 설계하는 사용자(개발자)가 정의한다. 
	- ex. DB를 정규화하여 여러 테이블로 나누고, 그 테이블 간의 관계(외래 키)를 설정
	  
- **참조 무결성(Referential Integrity)**
	- 외래 키(Foreign Keys)를 통해 테이블 간의 관계를 강제하고, `CASCADE` 옵션 등을 사용하여 부모 레코드가 삭제될 때 자식 레코드도 자동으로 삭제되도록 하여 일관성을 유지할 수 있다
- **ACID 속성**
	- 특히 원자성(Atomicity)과 격리성(Isolation)은 데이터 일관성을 보장하는 데 핵심적인 역할을 합니다.
		- **원자성**: 여러 테이블에 걸친 트랜잭션이 있을 때, 모든 쿼리가 성공하거나 (커밋), 단 하나라도 실패하면 전체가 롤백(모두 실패)되어 데이터가 모순되지 않도록 합니다.
		- **격리성**: 동시 트랜잭션이 서로의 변경 사항에 영향을 주지 않고 독립적으로 실행되는 것처럼 보이게 하여, 중간 단계의 불안정한 데이터가 노출되지 않도록 합니다.
		- **지속성** : 트랜잭션이 커밋되면, 시스템이 다운되어도 변경 사항은 영구적 
	>  ACIT 속성을 가진 RDBMS는 일관성을 높여준다



> [!WARNING] NoSQL 데이터베이스의 한계
> - 대부분의 NoSQL 데이터베이스는 관계형 데이터베이스처럼 **서로 다른 컬렉션(Collection)이나 문서(Document)에 걸쳐 원자성을 보장하지 않는다.** 
> - 즉, 한 컬렉션 내에서는 원자성을 가질 수 있지만, **여러 컬렉션을 동시에 업데이트할 때는 데이터 일관성을 보장하기 어렵**다.

---
### 3. 읽기 일관성 (Consistency during Reads)

#### Concept
**데이터 변경 후, 해당 변경 사항이 읽기 작업에 즉시 반영되는지 여부**에 관한 문제

- **정의**: 어떤 트랜잭션이 데이터를 업데이트한 후, 다른 트랜잭션이 그 데이터를 읽으려고 할 때 **새롭게 업데이트된 값을 즉시 받아볼 수 있는지**를 의미

#### 분산 환경에서의 문제 

✅**단일 서버 환경** 
- 만약 데이터베이스 서버가 **단 하나뿐이라면**, 읽기 일관성 문제는 발생하지 않는다. 
- 한 서버 내에서 값을 업데이트하면, 이어서 읽는 모든 트랜잭션은 당연히 그 새로운 값을 얻게 된다(단일 서버 환경에서는 RDBMS가 최적일 수 있다)

💢**분산 환경** 
실제 환경에서는 백만 명의 사용자처럼 대규모 트래픽을 처리하기 위해 **데이터베이스 서버를 확장
(Scale Out)**해야 한다다.
- 이를 위해 **캐시**를 추가하고, **여러 노드(Nodes)**를 사용한다.
- 일반적으로 하나의 **리더(Leader) 노드**가 모든 쓰기(Writes)를 처리하고, 여러 **팔로워(Follower) 노드**가 읽기(Reads)를 처리하는 **리더-팔로워(Leader-Follower) 아키텍처**를 구성

>[!danger] 문제 발생 지점
>리더 노드에서 데이터가 업데이트되면, 이 변경 사항은 팔로워 노드로 복제(Replication)되어야 합니다. 이 복제 과정에는 **시간 지연(latency)**이 발생할 수 있습니다. 따라서 팔로워 노드가 아직 업데이트된 데이터를 받지 못한 상태에서 읽기 요청이 들어오면, **오래된(stale) 데이터를 읽게 될 수 있습니다.** 이것이 **읽기 일관성 문제**의 핵심입니다.


## 결과적 일관성 (Evenctual Consistency)
Scale-out or Cashing을 도입할 때 발생하는 문제
> 문제점 : 복제 및 캐싱 시 Incosistency Read 발생 

분산 시스템에서 **높은 가용성과 확장성**을 추구할 때 불가피하게 **강한 일관성(Strong Consistency)을 포기**하게 되며, 그 **대안**으로 등장하는 느슨한 일관성 모델 중 하나가 **결과적 일관성**이다.
### ❓What is 결과적 일관성 ❓
> **일정 시간이 지난 후 결국에는 모든 노드의 데이터가 동일하게 수렴하는 일관성 모델**

- 어떤 시점 이후 더 이상 **쓰기 작업이 없다면**, 결국 모든 **읽기 작업은 동일한 값을 반환**하게 된다.
- 이는 **즉각적인 동기화는 되지 않지만**, 시간이 지나면 일관성이 보장된다는 의미
- 추가 가정 : 결과적 일관성은 원본 데이터가 정확하다는 가정
	- 데이터 자체가 손상되었다면 결과적 일관성도 이를 고칠 수 없다.


### ❓왜 필요할까❓
분산 시스템에서는 다음과 같은 것들을 도입한다
- Scale-out : 여러 서버에 데이터를 분산 저장
- Cashing : 데이터를 메모리에 복제해서 빠르게 응답 

> [!WARNING] 이 경우, 복제 or 캐싱된 값이 원본과 '즉시' 일치하지 않을 수 있다 ➡ 일시적 불일치 발생 
> - 쓰기 연산은 보통 하나의 노드에 먼저 적용되고, 이후 다른 노드에 비동기적으로 전파된다.


### 분산 시스템의 일관성 포기 
분산시스템에서는 고가용성과 확장을 위해 일관성을 희생한다.

> 데이터가 2개 이상의 장소에 존재하는 순간, 복사본들 사이에 일시적인 불일치가 발생한다.

하지만, 결과적 일관성에 관점에서 보면 분산시스템도 일관적이긴하다.

### ❓언제 결과적 일관성을 허용❓
>어떤 경우에는 성능 및 확장을 위하여, 강한 일관성은 포기하고 결과적 일관성만 허용해야하는 경우도 있다.

1. 허용 가능한 경우 ✅
	- 좋아요/조회수 : 잠깐 숫자 다르게 보인다고 심각한 문제는 아니다
	- 알림 시스템 : 약간 지연되어도 무방 
	- 로그 시스템

2. 허용 불가능한 경우 ❌
	- 금융 거래 : 치명적 
	- 재고 관리 



