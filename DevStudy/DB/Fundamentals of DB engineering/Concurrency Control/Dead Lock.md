> 여러 트랜잭션이 서로의 자원을 기다리면서 영원히 진행되지 못하는 상태

목차
- Dead락이란?
- Dead락이 나오는 경우(조건)
- OS에서 Dead Lock 해결 
- 프로그래밍에서 Dead Lock 해결


### ❓What is Dead Lock (교착 상태)
- 두 개 이상의 트랜잭션이 **서로 다른 자원(예: 테이블의 행, 인덱스 엔트리 등)을 점유한 상태에서 상대방이 점유한 자원을 요청하며 무한정 기다리는 교착 상태**를 의미


### ❓언제 Dead Lock이 발생하는가?
> [!EXAMPLE] Dead Lock은 아래의 4가지 조건을 모두! 만족해야 일어난다.
> - **Mutual Exclusive (상호 배제)**
> 	- 리소스를 공유해서 사용할 수 없다.
> - **Hold and Wait (점유 대기)**
> 	- 리로스를 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
> - **No preemption(비선점)**
> 	- 리소스 반환(release)은 오직 그 리소스를 취득한 프로세스만 가능하다.
> - **Circular wait(순환대기)**
> 	- 프로세스들이 순환 형태로 서로의 리소스를 기다린다.

![[Pasted image 20250605133547.png]]
특히나 DB를 여러개 사용할 경우 위의 사진처럼 ROCK이 일어나면 엄청난 network 비용이 든다.

### 데드락이 발생하는 전형적인 시나리오

두 트랜잭션 `T1`과 `T2`가 `A`라는 행과 `B`라는 행에 접근한다고 가정

| 시간  | 트랜잭션 T1             | 트랜잭션 T2             |
| :-- | :------------------ | :------------------ |
| 1   | `LOCK A` (A를 잠금)    |                     |
| 2   |                     | `LOCK B` (B를 잠금)    |
| 3   | `LOCK B` (B를 잠금 시도) |                     |
| 4   |                     | `LOCK A` (A를 잠금 시도) |

- 상황 : `T1`은 `A`를 잠근 후 `B`를 잠그려 하고, `T2`는 `B`를 잠근 후 `A`를 잠그려 하는 상황
- 대기
	- 시간 3에서 `T1`은 `B`가 `T2`에 의해 잠겨 있어 대기합니다.
	- 시간 4에서 `T2`는 `A`가 `T1`에 의해 잠겨 있어 대기합니다.
- 결과적으로
	- `T1`은 `T2`가 `B`를 놓아주기를 기다리고, `T2`는 `T1`이 `A`를 놓아주기를 기다리며, 
	- 둘 다 영원히 진행되지 못하는데, 이것이 "**데드락**"이다.


#### 실험 전 초기 상태
```bash
        List of relations
 Schema | Name | Type  |  Owner   
--------+------+-------+----------
 public | test | table | postgres
(1 row)

postgres=# select * from test;
 id 
----
(0 rows)
```

#### 테스트 : 트랜잭션 흐름 및 데드락 발생 
```SQL
T1
BEGIN transaction;

T2
BEGIN transaction;

T1
INSERT INTO test VALUES(20); -- 아직 COMMIT하지 않음

T2
INSERT INTO test VALUES(21); -- 정상 실행
INSERT INTO test VALUES(20);
-- ❗대기 상태(락) 발생 (T1이 같은 값 20을 먼저 넣었기 때문에)

T1 
INSERT INTO test VALUES(20);
❌ 데드락 오류 발생

**🔐발생 오류** 
ERROR:  deadlock detected
DETAIL:  Process 72 waits for ShareLock on transaction 757; blocked by process 145.
Process 145 waits for ShareLock on transaction 758; blocked by process 72.
HINT:  See server log for query details.
CONTEXT:  while inserting index tuple (0,4) in relation "test_pkey"
```

**❓왜 데드락이 발생했는가❓**
1. T1이 먼저 `id=20`을 INSERT함 
	- 아직 커밋하지 않았지만 **MVCC에 의해 메모리에는 존재함**
2. 이후 T2가 동일한 `id=20`을 INSERT 하려 함 
	- PK 제약 조건 위반 여부 확인 중, T1이 커밋을 안 했으므로 **T2는 T1의 트랜잭션 결과를 기다림**
	  
3. 그러다 T1이 다시 **같은 값을 INSERT 시도** 
	- 이 시점에서 **T1은 T2의 트랜잭션을 기다리게 됨**

- T1은 T2의 락을 기다림
- T2는 T1의 락을 기다림  
    → 🔁 **데드락 조건(Circular Wait)이** 충족되며 데드락 발생
![[Pasted image 20250605132504.png]]
#### PoswgreSQL의 데드락 감지 방식 
- PostgreSQL은 **락 대기 그래프**를 주기적으로 확인하고 **사이클이 발견되면 데드락으로 판단**
	- 트랜잭션 간 의존관계를 그래프의 형태로 추적
	- 그래프에 cycle이 발생하면 cycle을 제거할 수 있도록 트랜잭션을 Rollback
	  
- 그 중 **가장 늦게 트랜잭션에 진입한 프로세스**를 **자동 롤백**시켜 데드락 해소
> Postgres의 데드락 해결법 ➡ 데드락 일으킨 트랜잭션 **롤백** 시키기 



>[!question] 아무것도 커밋하지 않았는데 Lock이 일어난 이유 ❓
>- Row는 commit이 일어나지 않았지만, Memory에는 일어났다.
>- postgres는 memory의 row를 체크하고 locking을 진행했던 것 








### OS의 데드락 해결방법 
>[!tip] 아래의 방법들이 있다. (하지만 속 시원한 해결은 없다)
>- 데드락 방지
>- 데드락 회피
>- 데드락 감지와 복구
>- 데드락 무시 

#### 데드락 방지 
앞서 말한 데드락 발생 조건 중 하나가 충족되지 않게 **시스템을 디자인하는 것.**
`4가지 조건을 만족해야 데드락이 된다는 것 = 하나라도 만족하지 않으면 데드락 실패`

**방법**
1. **Mutual Exclusive(상호 배제) 조건 방지** 
	- 리소스를 공유 가능하게 하는 것 
	- **단점 💢**
		- 비현실적 : 현실적으로는 불가능 Cuz 공유를 막는 이유가 있겠죠 
		- 리소스 중에 Mutual Exclusive가 보장되야 하는 리소스들은 이런 방법 절대 못 씀 
	  
2. **Hold and Wait(점유 대기) 조건 방지** 
	- 사용할 리소스들을 모두 획득한 뒤에 시작 
	- 또는, 리소스를 전혀 가지지 않은 상태에서만 리소스 요청 
	- 이렇게 하면 대기할 필요도 없고, 리소스를 점유하고 있지 않아서 그 리소스를 필요로하는 다른 프로세스(스레드)에도 영향 God
	- **단점 💢**
		- 리소스 사용 효율이 떨어진다.
3. **No preemption(비 선점) 조건 방지** 
	- 추가적인 리소스를 **기다려야 할 때, 이미 획득한 리소스를 다른 프로세스가 선점 가능하도록** 하는 것 
	- 즉, 이미 선점해도 다른 프로세스에게 양보하도록 함
	  
4. **Circular Wait(순환 대기) 조건 방지** 
	- 모든 리소스에 순서 체계를 부여하여 **오름차순으로 리소스를 요청** 
	- 데드락 방지 기술 중 많이 쓰이는 방식 ⭐


#### 데드락 회피 
데드락 방지 = 시스템 디자인을 통해 방지 

>[!tip] 실행 환경에서 추가적인 정보를 활용하여 데드락이 발생할 것 같은 상황을 회피하는 것

대표적인 데드락 회피 알고리즘 = **Banker Algorithm**
- 리소스 요청을 허락해줬을 때, 데드락이 발생할 가능성이 있다면 리소스를 할당해도 **안전할 때까지 계속 요청을 거절** 하는 알고리즘 
#### 데드락 감지와 복구 

>[!tip] 데드락을 **허용**하고 데드락이 **발생하면 복구**하는 전략 

데드락 감지 후 **복구 전략은 크게 2가지**이다.
1. **프로세스 종료**
	- 극단적이긴하다. 
	- 그러나 현업에서 가끔씩 쓰기도 한다.
	  
2. **리소스의 일시적 선점을 허용하는 것** 


#### 데드락 무시 

>은근히 OS가 이런 방식을 많이 쓴다.


## 자바에서 예제 


데드락 예시 
어떻게 데드락 해결하는지 


