> 여러 트랜잭션이 서로의 자원을 기다리면서 영원히 진행되지 못하는 상태

목차
- Dead락이란?
- Dead락이 나오는 경우(조건)
- OS에서 Dead Lock 해결 
- 프로그래밍에서 Dead Lock 해결


### ❓What is Dead Lock (교착 상태)
- 두 개 이상의 트랜잭션이 **서로 다른 자원(예: 테이블의 행, 인덱스 엔트리 등)을 점유한 상태에서 상대방이 점유한 자원을 요청하며 무한정 기다리는 교착 상태**를 의미


### ❓언제 Dead Lock이 발생하는가?
> [!EXAMPLE] Dead Lock은 아래의 4가지 조건을 모두! 만족해야 일어난다.
> - **Mutual Exclusive (상호 배제)**
> 	- 리소스를 공유해서 사용할 수 없다.
> - **Hold and Wait (점유 대기)**
> 	- 리로스를 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
> - **No preemption(비선점)**
> 	- 리소스 반환(release)은 오직 그 리소스를 취득한 프로세스만 가능하다.
> - **Circular wait(순환대기)**
> 	- 프로세스들이 순환 형태로 서로의 리소스를 기다린다.


### 데드락이 발생하는 전형적인 시나리오

두 트랜잭션 `T1`과 `T2`가 `A`라는 행과 `B`라는 행에 접근한다고 가정

| 시간  | 트랜잭션 T1             | 트랜잭션 T2             |
| :-- | :------------------ | :------------------ |
| 1   | `LOCK A` (A를 잠금)    |                     |
| 2   |                     | `LOCK B` (B를 잠금)    |
| 3   | `LOCK B` (B를 잠금 시도) |                     |
| 4   |                     | `LOCK A` (A를 잠금 시도) |

- 상황 : `T1`은 `A`를 잠근 후 `B`를 잠그려 하고, `T2`는 `B`를 잠근 후 `A`를 잠그려 하는 상황
- 대기
	- 시간 3에서 `T1`은 `B`가 `T2`에 의해 잠겨 있어 대기합니다.
	- 시간 4에서 `T2`는 `A`가 `T1`에 의해 잠겨 있어 대기합니다.
- 결과적으로
	- `T1`은 `T2`가 `B`를 놓아주기를 기다리고, `T2`는 `T1`이 `A`를 놓아주기를 기다리며, 
	- 둘 다 영원히 진행되지 못하는데, 이것이 "**데드락**"이다.


### OS의 데드락 해결방법 
>[!tip] 아래의 방법들이 있다. (하지만 속 시원한 해결은 없다)
>- 데드락 방지
>- 데드락 회피
>- 데드락 감지와 복구
>- 데드락 무시 

#### 데드락 방지 
앞서 말한 데드락 발생 조건 중 하나가 충족되지 않게 **시스템을 디자인하는 것.**
`4가지 조건을 만족해야 데드락이 된다는 것 = 하나라도 만족하지 않으면 데드락 실패`

**방법**
1. **Mutual Exclusive(상호 배제) 조건 방지** 
	- 리소스를 공유 가능하게 하는 것 
	- **단점 💢**
		- 비현실적 : 현실적으로는 불가능 Cuz 공유를 막는 이유가 있겠죠 
		- 리소스 중에 Mutual Exclusive가 보장되야 하는 리소스들은 이런 방법 절대 못 씀 
	  
2. **Hold and Wait(점유 대기) 조건 방지** 
	- 사용할 리소스들을 모두 획득한 뒤에 시작 
	- 또는, 리소스를 전혀 가지지 않은 상태에서만 리소스 요청 
	- 이렇게 하면 대기할 필요도 없고, 리소스를 점유하고 있지 않아서 그 리소스를 필요로하는 다른 프로세스(스레드)에도 영향 God
	- **단점 💢**
		- 리소스 사용 효율이 떨어진다.
3. **No preemption(비 선점) 조건 방지** 
	- 추가적인 리소스를 **기다려야 할 때, 이미 획득한 리소스를 다른 프로세스가 선점 가능하도록** 하는 것 
	- 즉, 이미 선점해도 다른 프로세스에게 양보하도록 함
	  
4. **Circular Wait(순환 대기) 조건 방지** 
	- 모든 리소스에 순서 체계를 부여하여 **오름차순으로 리소스를 요청** 
	- 데드락 방지 기술 중 많이 쓰이는 방식 ⭐


#### 데드락 회피 
데드락 방지 = 시스템 디자인을 통해 방지 

>[!tip] 실행 환경에서 추가적인 정보를 활용하여 데드락이 발생할 것 같은 상황을 회피하는 것

대표적인 데드락 회피 알고리즘 = **Banker Algorithm**
- 리소스 요청을 허락해줬을 때, 데드락이 발생할 가능성이 있다면 리소스를 할당해도 **안전할 때까지 계속 요청을 거절** 하는 알고리즘 
#### 데드락 감지와 복구 

>[!tip] 데드락을 **허용**하고 데드락이 **발생하면 복구**하는 전략 

데드락 감지 후 **복구 전략은 크게 2가지**이다.
1. **프로세스 종료**
	- 극단적이긴하다. 
	- 그러나 현업에서 가끔씩 쓰기도 한다.
	  
2. **리소스의 일시적 선점을 허용하는 것** 


#### 데드락 무시 

>은근히 OS가 이런 방식을 많이 쓴다.


## 자바에서 예제 


데드락 예시 
어떻게 데드락 해결하는지 


