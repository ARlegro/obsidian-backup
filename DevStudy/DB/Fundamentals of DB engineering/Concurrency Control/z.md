


낙관적 락을 쓰는 이유가 결국 오버헤드 줄이고 버전 체크로 충돌 감지하는건데 

### 문제의 시나리오 1 - Modify를 위해 Lock 중인 행에 다른 트랜잭션도 Modify 시도

내부적으로 PostgreSQL은 DELETE시 `FOR UPDATE`이긴한데 그냥 예시에서는 `FOR NO KEY UPDATE`사용했는데 지금 시나리오에서는 큰 차이 없어서 그냥 진행 
#### 타임라인

|     | A                                                                               | B                                                                            |
| --- | ------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| 목적  | Board 테이블 값 삭제                                                                  | Board 테이블 값 수정                                                               |
|     | `SELECT * FROM boards WHERE id = 40 FOR NO KEY UPDATE`<br>(배타락이지만 참조값 READ는 허용) | <br>                                                                         |
|     |                                                                                 | `UPDATE boards SET title = 'rock' WHERE id = 40`<br>(대기 상태 빠짐 Cuz A에서 락 걸어서) |
|     | `DELETE FROM boards where id = 40;`                                             | **아직도 대기 상태**                                                                |
|     | COMMIT                                                                          | UPDATE 실패                                                                    |
![[Pasted image 20250606164924.png]]

>[!danger] 큰 문제는 A로 인해 Board가 삭제될때까지 B는 계속 대기라는 것이다!

#### 실제 이런 경우 예시 

다수의 디바이스가 `INSERT` 또는 `UPDATE`를 할 때, 매번 행 잠금을 걸면 데이터베이스가 멈출 수 있음








>어떻게 해야 해결 가능할까???

### 해결 1. 낙관적 락 
> DB 레벨에서 행을 장시간 잠그지 않고, 커밋 시점에 충돌 여부를 감지




B 커밋 시점에 JPA가 version 필드를 검사함
- 만약 A가 B보다 먼저 커밋하여 같은 행을 삭제했다면, B가 커밋 시점에 “해당 row 없음” 혹은 “버전 불일치”를 감지하여 `OptimisticLockException` 혹은 `EntityNotFoundException`이 발생
- B는 이 예외를 잡아서 “이미 삭제된 게시물입니다”라고 사용자에게 안내하거나, 재조회 후 다른 작업을 수행하도록 로직을 짤 수 있다.
  
  
### 해결 2. 락 타임아웃 

락을 기다리지 않고 바로 실패 처리하도록 조회 단계에서 락 타임아웃을 0으로 설정



### 해결 3. 쿼리 힌트 










