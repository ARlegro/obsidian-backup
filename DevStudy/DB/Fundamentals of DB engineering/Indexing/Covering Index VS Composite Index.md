> 커버링 인덱스 VS 복합 인덱스 



둘 다 컬럼을 묶는 것 같은데 다른 방법으로 인덱스를 생성하는 것을 보고 차이를 공부하고 싶어졌다.


### Covering Index 
[[Key vs Non-Key column Index]]
> 쿼리의 결과를 인덱스만으로 처리할 수 있도록 필요한 모든 컬럼을 포함하는 인덱스

쿼리에서 필요한 모든 데이터가 인덱스 자체 내에 모두 포함되어 있어서, **데이터베이스가 실제 테이블(힙)에 접근할 필요 없이 인덱스만으로 쿼리를 완료할 수 있는 인덱스**를 의미
- **목적** 
	- **Heap 접근 제어** : Heap(테이블)접근을 줄여 디스크 I/O를 최소화하고 쿼리 성능 극대화 
		- Heap접근은 굉장히 비용이 드는 작업이기에 최소화 하는 것이 좋다. 
	- **랜덤 I/O 비용 절감** 

#더블룩업줄이기  

- 일반 인덱스 :  **조건절(WHERE)** 에서만 사용 가능하지만,
- 커버링 인덱스 : "조건절 + SELECT절" 까지 모두 인덱스에서 처리할 수 있어 **Index Only Scan**이 가능하다.

> 중간 정리 : 커버링 인덱스는 쿼리에 필요한 모든 컬럼을 인덱스 내에 미리 저장해두어, 더블 룩업 과정을 생략하고 Index-Only-Scan을 가능하게 함 


예시 
```SQL 
CREATE INDEX ON students(id) INCLUDE (email);
```
- id : 인덱스 Key 
- email : INCLUDE 컬럼 

```SQL
-- 이 쿼리는 테이블을 직접 접근하지 않고 인덱스만으로 처리 가능
SELECT email FROM students WHERE id = 101;
```

### Key Column vs Non-Key Column

|역할|Key Column|INCLUDE(Column) (Non-Key)|
|---|---|---|
|인덱스 정렬 기준|O|X|
|검색 조건 사용|O (`WHERE`)|X (사용 안 됨)|
|조회 컬럼 사용|O|O (`SELECT`에서 사용 가능)|
Non-Key컬럼이 검색조건과 정렬에 쓰일 수 없는 이유는 B-tree 내부 구조를 알아야 이해할 수 있다.
지금 단순하게 말하면 **Non-Key 컬럼은 B-tree 탐색에 쓰일 수 없는 컬럼**이다. 
따라서, 주의해야 함 

> 따라서, Include 컬럼이 조건절에 쓰이는 경우는 큰 성능을 가져올 수 없다.


> [!WARNING] VACUUM이 visibility map을 최신으로 유지해야 Index Only Scan이 가능하다.
> - 인덱스를 활용할때는 단순히 인덱스의 TID, PageNumber만 보는게 아니다 visibility map을 확인하면서 이게 Heap영역에 접근할 필요가 있는지를 확인을 하는 작업이 필요하다.
> 참고 : [[Index Scan VS Index-Only Scan]] - VACUUM


### 복합 인덱스(Composite Index)
> 여러 개의 컬럼을 하나의 인덱스로 묶은 것

- 정의 : **두 개 이상의 컬럼을 조합하여 생성된 인덱스**를 의미
- 목적 : 복합 인덱스는 **하나의 인덱스 안에 여러 컬럼을 포함**시켜, **해당 컬럼들이 조합된 조건절을 빠르게 처리**할 수 있도록 돕는다.
- 인덱스 내의 컬럼 순서가 매우 종요하다 Cuz 순서에 따라 활용도가 달라진다.

> [!WARNING] 컬럼 순서가 중요한 이유 in 복합 인덱스 
> - 인덱스는 **왼쪽에서부터 오른쪽 방향으로만 탐색**이 가능하다
> - 따라서 아래의 SQL인덱스가 있다고 가정할 때  SQL문에서 `name`이 빠지면  `grade`는 인덱스를 단독으로 활용하기 어렵다.
> - 이는 **사전에서 '이름-성적' 순으로 정렬해놓고 '성적만' 찾는 것이 어려운 것**과 유사
```SQL 
CREATE INDEX idx_name_grade ON students (name, grade);
```

> [!TIP] 사용 꿀 팁 : 자주 함께 쓰이는 조건 또는 선택도가 높은 컬럼을 앞에 배치하면 효율이 높다.


✅**복합 인덱스가 커버링 인덱스가 될 수 있다.**
- 복합 인덱스를 만들 때, 쿼리 절에서 필요로하는 컬럼들을 모두 포함하면 해당 쿼리에 대해 **복합 인덱스는 커버링 인덱스로 작동**

✅**모든 복합 인덱스가 커버링 인덱스는 아니다** 
- 복합 인덱스가 생성되었더라도, 쿼리가 인덱스에 포함되지 않은 다른 컬럼을 필요로 한다면, 테이블에 접근해야 하므로 커버링 인덱스가 아니다.



### 정리

| 특성         | 복합 인덱스 (Composite Index)             | 커버링 인덱스 (Covering Index)                                                                                     |
| :--------- | :----------------------------------- | :----------------------------------------------------------------------------------------------------------- |
| **개념**     | 2개 이상의 컬럼으로 구성된 인덱스                  | 쿼리에서 필요한 모든 데이터를 인덱스 내에서 제공하는 인덱스의 역할                                                                        |
| **구성**     | 다중 컬럼                                | 쿼리에서 필요한 모든 컬럼                                                                                               |
| **목적**     | 다중 조건 검색 효율화, 정렬 최적화                 | 테이블 접근(Heap Lookup) 최소화, 쿼리 성능 극대화                                                                           |
| **테이블 접근** | 쿼리하는 컬럼에 따라 테이블 접근 필요 여부 결정 (대부분 필요) | **테이블 접근 불필요**                                                                                               |
| **예시**     | `idx_name_grade (name, grade)`       | `idx_name_grade_id (name, grade, id)` 또는 `idx_name_id_covering_grade (name, id) INCLUDE (grade)` (특정 쿼리에 대해) |

|항목|복합 인덱스 (Key만)|INCLUDE 인덱스|
|---|---|---|
|WHERE 조건 가능|✅ (Key 컬럼 기준 탐색 가능)|❌ (INCLUDE 컬럼은 조건에 못 씀)|
|SELECT 컬럼 포함|✅ (Key 컬럼이면 포함됨)|✅ (INCLUDE 컬럼이기 때문에 포함됨)|
|정렬 정보 유지|✅ (B-Tree로 정렬)|❌ (정렬 정보 없음)|
|탐색 성능 기여|✅ (탐색 경로의 일부)|❌ (탐색 경로에 포함 안 됨)|
|Index Only Scan|✅ (조건과 결과 모두 Key로 커버 가능할 때)|✅ (INCLUDE로 결과 컬럼만 추가 가능할 때)|


|질문|설계 지침|
|---|---|
|이 컬럼이 `WHERE` 절 **비교식**에 자주 등장하나?|**Key 컬럼**으로 넣어라.|
|이 컬럼은 단순히 **SELECT** 로만 읽히나?|`INCLUDE` 로 넣어 Heap 접근을 없애라.|
|둘 다 자주 쓰이나?|Key 에 넣거나 **두 개 인덱스**(하나는 조건용, 하나는 조회용)를 검토.|

> 핵심 : **INCLUDE** 컬럼은 인덱스 페이지에 실려만 있을 뿐,  **정렬·탐색 로직에는 관련이 없다**
