
초기 세팅 
```SQL
                                         Table "public.boards"
   Column   |              Type              | Collation | Nullable |             Default              
------------+--------------------------------+-----------+----------+----------------------------------
 id         | bigint                         |           | not null | generated by default as identity
 content    | character varying(255)         |           |          | 
 created_at | timestamp(6) without time zone |           |          | 
 title      | character varying(255)         |           |          | 
Indexes:
    "boards_pkey" PRIMARY KEY, btree (id)
```
```SQL
INSERT INTO boards(created_at, title, content)
SELECT 
    NOW() - INTERVAL '1 day' * FLOOR(random() * 3650 + 1)
         + INTERVAL '1 second' * FLOOR(random() * 86400),
    'Title' || LPAD(n::text, 8, '0'),
    'Content' || LPAD(n::text, 8, '0')
FROM generate_series(1,10_000_000) AS s(n)
```



```SQL
EXPLAIN ANALYZE SELECT * FROM boards ORDER BY created_at
```

```sql
QUERY PLAN

Gather Merge  (cost=850613.62..1822904.27 rows=8333338 width=46) (actual time=1559.700..3323.878 rows=10000000 loops=1)
  Workers Planned: 2
  Workers Launched: 2
  ->  Sort  (cost=849613.60..860030.27 rows=4166669 width=46) (actual time=1550.619..1896.450 rows=3333333 loops=3)
        Sort Key: created_at
        Sort Method: external merge  Disk: 181800kB
        Worker 0:  Sort Method: external merge  Disk: 183144kB
        Worker 1:  Sort Method: external merge  Disk: 183168kB
        ->  Parallel Seq Scan on boards  (cost=0.00..135124.69 rows=4166669 width=46) (actual time=0.052..203.775 rows=3333333 loops=3)
Planning Time: 0.339 ms
Execution Time: 3592.208 ms
```



```SQL
-- CREATE INDEX ON boards(created_at)
-- VACUUM ANALYZE boards;
EXPLAIN ANALYZE SELECT * FROM boards ORDER BY created_at
```
```SQL
QUERY PLAN

Index Scan using boards_created_at_idx on boards  (cost=0.43..633214.35 rows=10000006 width=46) (actual time=0.065..23299.189 rows=10000000 loops=1)
Planning Time: 0.260 ms
Execution Time: 23588.276 ms
```
- created_at으로 인덱스를 만들었는데 더 느려졌다.
- 이유 추측
	- 어쩄든 index scan하러 Heap테이블에 가야되는데 랜덤 I/O가 발생 
	- 차라리 전체를 가져오는거면 순차 접근이 훨씬 빠름 


## LIMIT + 인덱스 비교 
하지만 LIMIT이 적용된다면???
아래의 명령을 인덱스 있을 경우 VS 인덱스 없을 경우를 비교할 것 
```SQL
EXPLAIN ANALYZE SELECT * FROM boards ORDER BY created_at LIMIT 10000
```

### 1만 LIMIT (전체의 1/1000)

#### 💢인덱스 X  
```SQL 
QUERY PLAN

Limit  (cost=433784.91..434951.65 rows=10000 width=46) (actual time=424.817..433.054 rows=10000 loops=1)
  ->  Gather Merge  (cost=433784.91..1406073.69 rows=8333322 width=46) (actual time=416.953..424.714 rows=10000 loops=1)
        Workers Planned: 2
        Workers Launched: 2
        ->  Sort  (cost=432784.88..443201.53 rows=4166661 width=46) (actual time=406.204..406.739 rows=3873 loops=3)
              Sort Key: created_at
              Sort Method: top-N heapsort  Memory: 1960kB
              Worker 0:  Sort Method: top-N heapsort  Memory: 1958kB
              Worker 1:  Sort Method: top-N heapsort  Memory: 1955kB
              ->  Parallel Seq Scan on boards  (cost=0.00..135124.61 rows=4166661 width=46) (actual time=0.023..198.289 rows=3333333 loops=3)
Planning Time: 0.157 ms
JIT:
  Functions: 1
  Options: Inlining false, Optimization false, Expressions true, Deforming true
  Timing: Generation 0.160 ms (Deform 0.000 ms), Inlining 0.000 ms, Optimization 1.381 ms, Emission 6.473 ms, Total 8.014 ms
Execution Time: 498.489 ms
```


#### ✅인덱스 O
```SQL
QUERY PLAN

Limit  (cost=0.43..633.65 rows=10000 width=46) (actual time=0.033..44.786 rows=10000 loops=1)
  ->  Index Scan using boards_created_at_idx on boards  (cost=0.43..633214.35 rows=10000006 width=46) (actual time=0.032..44.042 rows=10000 loops=1)
Planning Time: 0.556 ms
Execution Time: 45.246 ms
```


>[!tip] Limit 조건에서는 인덱스가 있는게 10배나 빨랐다.
>그 이유는 불필요한 페이지 접근이 많이 없기 떄문
>반면 LIMIT이 없다면 어쨌든 전체 페이지에 접근해야하는데 INDEX에 정렬된 기준으로 페이지에 접근하면 중복접근이 발생해서 오히려 더 안 좋은 성능이 나온다.


### 100만 LIMIT (전체의 1/10)

```SQL
EXPLAIN ANALYZE SELECT * FROM boards ORDER BY created_at LIMIT 1_000_000
```


#### 💢인데스 X

```SQL 
QUERY PLAN

Limit  (cost=850613.62..967288.43 rows=1000000 width=46) (actual time=1542.263..1788.215 rows=1000000 loops=1)
  ->  Gather Merge  (cost=850613.62..1822904.27 rows=8333338 width=46) (actual time=1498.450..1695.302 rows=1000000 loops=1)
        Workers Planned: 2
        Workers Launched: 2
        ->  Sort  (cost=849613.60..860030.27 rows=4166669 width=46) (actual time=1482.421..1517.699 rows=333879 loops=3)
              Sort Key: created_at
              Sort Method: external merge  Disk: 179808kB
              Worker 0:  Sort Method: external merge  Disk: 185240kB
              Worker 1:  Sort Method: external merge  Disk: 183016kB
              ->  Parallel Seq Scan on boards  (cost=0.00..135124.69 rows=4166669 width=46) (actual time=0.021..245.080 rows=3333333 loops=3)
Planning Time: 0.503 ms
JIT:
  Functions: 1
  Options: Inlining true, Optimization true, Expressions true, Deforming true
  Timing: Generation 0.108 ms (Deform 0.000 ms), Inlining 39.498 ms, Optimization 1.157 ms, Emission 3.149 ms, Total 43.912 ms
Execution Time: 1847.572 ms
```
> Flow : Parallel Seq Scan ➡ Sort ➡ Gather Merge

#### ✅인덱스 O

```SQL 
QUERY PLAN

Limit  (cost=0.43..63320.14 rows=1000000 width=46) (actual time=0.022..2242.519 rows=1000000 loops=1)
  ->  Index Scan using boards_created_at_idx on boards  (cost=0.43..633197.91 rows=10000006 width=46) (actual time=0.021..2183.731 rows=1000000 loops=1)
Planning Time: 0.133 ms
Execution Time: 2270.836 ms
```
> Flow : Index Scan 

#### 중요 교훈 
>[!tip] 이번에는 인덱스를 설정해둔 쿼리가 더 느렸다!!!
>- 인덱스 스캔이 항상 빠른거는 아니다
>- 어쩔떄는 Parallel Seq Scan ➡ Sort ➡ Gather Merge 이런 Flow가 더 빠를 수도 있다.
>- 이유
>	- INDEX 에는 정렬이 되어있지만 정렬된 ROW들을 하나하나 접근할 때, 그 해당 ROW가 갖고 있는 페이지에 접근할 텐데, 너무 많은 ROW라면 중복 접근하는 페이지가 많아질 것. 따라서 느림 ⭐⭐⭐
>	- (차라리 Index-Only-Scan 이면 모를까)




