
Primary Key = 기본 키 
Secondary Key = 보조 키 

> 단순히 Primary Key는 Unique하다고만 알고 있을 것이다,

> 두개의 개념은 데이터 저장 방식과 쿼리 성능에 직접적인 영향을 미치기에 이해 必


### 들어가기 앞서 : 테이블 공간과 Heap의 이해 

> [!tip] 힙(Heap) : 실제 테이블 데이터(행)가 저장되는 디스크의 전용 영역
- **기본적 저장 방식** 
	- 기본적으로 힙 내의 행들에는 고유한 순서가 없다. 
	- 즉, **기본적으로 정렬되지 않은 상태** (priamry key, secondary key 등 없다고 가정 )
	- 새 행은 단순히 끝에 추가될 뿐
	  
- **성능** 
	- 힙에 접근하는 것은 기본적으로 **느린 작업**이다.
	- 따라서, **순수하게 힙(Heap)에만 의존**하는 테이블에서 데이터를 검색하는 것은 데이터베이스가 필요한 데이터를 찾기 위해 **정렬되지 않은 데이터를 스캔해야 하므로 느릴 수 있다**


### 기본키와 클러스터링 
> 테이블에 Priamry Key같은 개념을 도입하는 것은 '클러스터링'이라고 부른다.

#### 클러스터링(Clustering)이란 ❓
- 물리적으로 테이블 데이터를 **특정 인덱스 기준으로 재정렬**
- 명령어 : `CLUSTRE` (Postgre 기준)
- 목적 : 성능 향상을 위해 일시적인 정렬 최적화
- 읽기 전용 테이블에 적합 

> MySQL과 PostgreSQL은 인덱스 구조가 달라서 설계 전략이 다름 

기본적으로 정렬이 되어있다
- 이러한 정렬에는 비용이 드는 작업?

PostgreSQL 같은 경우는 clustered index가 있다.
일반적으로 primary key로 불림
#### 클러스터링 인덱스 
**✔개념** 
- 기본 키(Primary Key)를 기준으로 데이터가 물리적으로 정렬된 상태로 저장된 인덱스
- 테이블의 실제 데이터 행이 클러스터링 인덱스에 저장되어 있으며, 기본 키 값에 따라 정렬됨
- InnoDB 스토리지 엔진에서만 사용 가능




#### 클러스터링 작동 방식 예시 

가정 : 기본 키 값이 1, 8, 2인 행을 삽입
1. 먼저 1이 삽입
2. 그다음 8이 삽입
3. 2가 삽입 시도
	- 기본 키이기 때문에 데이터베이스는 2가 1과 8에 대한 정확한 정렬된 위치에 놓이도록 해야한다.
	- 이는, 8과 같은 다른 행을 아래로 "밀어내어" **2를 위한 공간을 만들고 정렬된 순서를 유지해야 함**을 의미

#### 클러스터링 장단점 

앞선 예시를 통해 장단점을 알 수 있다.

**💚장점** 
- **성능**
	- 이는 특히 범위 쿼리에서 큰 효과를 발휘한다.
	- 가령 1~10의 primary key를 가진 데이터를 조회하는 쿼리를 짰을 때, 단 한번의 page I/O작업으로 데이터를 조회할 수 있어진다.

💢단점 
- 정렬에 드는 비용     




### 기본키가 무작위일 때의 성능 - UUID

> UUID는 Random 데이터이기 때문에 삽입 시 이 값을 기준으로는 정렬이 되어있지 않다.

- UUID를 기본키로 사용할 경우 Random 특성 때문에 Heap안에서 이리저리 이동하게 될 것이고, 데이터베이스가 이 행들을 삽입할 때 수행하는 **메모리 캐싱의 이점을 얻지 못할 것**
	- MySQL같은 '기본 키'기반 데이터베이스에서는 이런 한계가 있음 
- 일단 primary key값을 관점으로 볼 때는 굉장히 mess된 테이블이다.
- 랜덤 삽입 문제
	- 랜덤하게 생성되어 새로운 레코드를 삽입할 때 디스크 페이지의 임의의 위치에 삽입
	- 이는 디스크 I/O 비용을 증가시킨다.
	- 일반적으로 클러스터링 인덱스는 연속적인 값(예: 자동 증가하는 숫자)으로 정렬되어 있을 때 성능이 좋지만, UUID는 연속적인 값이 아니므로 정렬의 이점을 잃게 됨
나중에 꼭 보기 : https://medium.com/@andrew_10845/databases-beyond-auto-increment-2101953fefc3


MySQL 예시 
- MySQL같은 경우 보조 키가 아닌 '기본 키'기반 데이터베이스다.
- 기본 키가 필수적이며, 테이블은 클러스팅 시 기본 키를 기준으로 클러스팅한다.


> [!INFO] 보조 인덱스를 사용하지 않고 이러한 순차적인 클러스터링된 인덱스를 사용하는 것도 좋다(더 공부하면 딥해지니 PASS)


## 보조키 


테이블이 뒤죽박죽인 상태로 있지만, **외부에 추가적인 구조**를 가지고 있는 것
테이블 안에 있는 것이 아니다 ❗❗
인덱스는 테이블 자체에는 순서가 없지만, **다른 구조 내에서 정렬되어 있다**
즉, 인덱스를 위한 **별도의 구조를 유지**하고 있다는 것 
이를 보조 인덱스(Secondary Index)라고 함 

이제  싶다면, 먼저 이 인덱스로 점프하여 검색을 수행하고, 

하지만 `SELECT`로 실제 행 자체를 가져오려면 먼저 이 보조 인덱스로 갔다가 검색을 수행하고 쿼리하려는 튜플이나 페이지를 수집. 근데 여기서 여전히 힙, 즉 테이블로 가서 가져와야 한다. 왜냐하면 **인덱스에서 모든 것을 찾을 수는 없기 때문**
이 보조 인덱스로 알 수 있는 것은 row id이다.
즉, 어쨌든 이 row id 에 맞는 데이터를 가져오려면 힙에 접근해야 한다는 것 
이게 Secondary key의 단점 




Postgres의 모든 인덱스는 보조 인덱스이다.

Postgres에는 기본 인덱스가 없다.



IOT = Index Oraganized Table 
