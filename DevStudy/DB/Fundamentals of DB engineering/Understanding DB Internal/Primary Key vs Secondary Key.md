
Primary Key = 기본 키 
Secondary Key = 보조 키 

> 단순히 Primary Key는 Unique하다고만 알고 있을 것이다,

> 두개의 개념은 데이터 저장 방식과 쿼리 성능에 직접적인 영향을 미치기에 이해 必

## 기본 키 (Primary Key)
### 1. 들어가기 앞서 : 테이블 공간과 Heap의 이해 
데이터베이스는 디스크에 데이터를 저장하기 위해 특정 영역을 할당한다.
이 영역을 '테이블 공간(Table_Space)'라고 하며, 실제 테이블의 행 데이터가 저장되는 곳을 일반적으로 **힙(Heap)** 이라고 부른다.
> [!tip] 힙(Heap) : 실제 테이블 데이터(행)가 저장되는 디스크의 전용 영역

#### 1.1. 힙의 기본적 저장 방식 
- **무질서한 저장**
	- **기본적으로** 힙 내의 행들에는 **고유한 순서가 없다.** 
	- Primary Key나 Secondary Key와 같은 제약 조건이 없는 테이블에 데이터를 삽입하면,  새 행은 단순히 힙의 끝에 추가될 뿐
	  
- **정렬되지 않은 상태**
	- 기본적으로 **정렬되지 않은 상태**로 데이터가 쌓입니다. (Primary Key, Secondary Key 등 인덱스가 없다고 가정)

#### 1.2. 힙 접근 성능
- **느린작업**
	- 힙에 접근하는 것은 기본적으로 **느린 작업**이다. 
	- 데이터베이스는 필요한 데이터를 찾기 위해 정렬되지 않은 데이터를 처음부터 끝까지 **순차적으로 스캔(Sequential Scan)** 해야 하기 때문
- **비싼 비용**
	- 위의 이유로, **순수하게 힙(Heap)에만 의존**하는 테이블에서 데이터를 검색하는 것은 비효율적
	- 데이터베이스가 필요한 데이터를 찾기 위해 **정렬되지 않은 데이터를 스캔해야 하므로**, 대량의 데이터에서는 성능 저하가 두드러진다.


### 2. 기본키와 클러스터링 
> 테이블에 Priamry Key같은 개념을 도입하는 것은 '클러스터링'이라는 개념과 연관된다.

#### 2.1. 클러스터링(Clustering)이란 ❓
>물리적으로 테이블 데이터를 **특정 인덱스 기준으로 재정렬**

클러스터링은 테이블의 물리적 데이터를 **특정 인덱스(주로 Primary Key)의 논리적 순서에 따라 디스크에 재정렬**하는 방식
- **목적** : 데이터 접근 성능 향상 (범위 쿼리에 매우 효과적)
- 명령어 : `CLUSTRE` (Postgre 기준)
- 읽기 전용 테이블에 적합 

#### 2.2. 클러스터링 인덱스 
**✔개념** 
- 기본 키(Primary Key)를 기준으로 데이터가 물리적으로 정렬된 상태로 저장된 인덱스
- 테이블의 실제 데이터 행이 클러스터링 인덱스에 저장되어 있으며, 기본 키 값에 따라 정렬됨
- InnoDB 스토리지 엔진에서만 사용 가능

#### 2.3. DB별 클러스터링 구현 방식 

1. **MySQL**
	- InnoDB 스토리지 엔진에서 모든 테이블은 **Primary Key를 기준으로 클러스터링**됩니다.
	  
2. **PostgreSQL**
	- 기본적으로 : **클러스터링 인덱스(Clustered Index)를 직접 지원하지 않는다.**  💢
	- 즉, 테이블 데이터는 기본적으로 힙(Heap) 형태로만 저장되며, 인덱스는 항상 별도의 구조로 존재
	- 하지만, `CLUSTER`명령어를 통해 **테이블 데이터를 특정 인덱스를 기준으로 한 번 정렬**할 수는 있다. ✅
		- **이는 일시적인 정렬 최적화**이며, 이후 삽입되는 데이터는 무작위로 힙에 추가된다.
		- 따라서, **읽기 전용** 또는 **거의 변경되지 않는 테이블에 적합**하며, 주기적으로 `CLUSTER` 명령어를 실행하여 정렬 상태를 유지해야 할 수 있다.

> MySQL과 PostgreSQL은 인덱스 구조가 달라서 설계 전략이 다름 

#### 클러스터링 작동 방식 예시 

가정 : 기본 키 값이 1, 8, 2인 행을 삽입
1. 먼저 1이 삽입
2. 그다음 8이 삽입
3. 2가 삽입 시도
	- 기본 키이기 때문에 데이터베이스는 2가 1과 8에 대한 정확한 정렬된 위치에 놓이도록 해야한다.
	- 이는, 8과 같은 다른 행을 아래로 "밀어내어" **2를 위한 공간을 만들고 정렬된 순서를 유지해야 함**을 의미

#### 클러스터링 장단점 

앞선 예시를 통해 장단점을 알 수 있다.

**💚장점** 
- **성능**
	- 이는 특히 **범위 쿼리에서 큰 효과**를 발휘한다.
	- 가령 1~10의 primary key를 가진 데이터를 조회하는 쿼리를 짰을 때, 단 한번의 page I/O작업으로 필요한 모든 데이터를 효율적으로 조회할 수 있다.
- **데이터 지역성**
	- 관련 데이터가 디스크 상에 가깝게 저장되어 있어 캐시 효율성이 높아진다.

**💢단점** 
- **삽입/업데이트 비용** : 데이터의 정렬 순서를 유지하기 위해 새로운 행을 삽입하거나 기존 행의 Primary Key를 업데이트할 때 추가적인 디스크 I/O (페이지 분할, 데이터 이동)가 발생할 수 있어 비용이 든다.
- 클러스터링 인덱스는 **테이블당 하나** : 그 하나의 인덱스로 테이블의 물리적 순서를 결정하는 것 


### 번외 : 기본키가 무작위일 때의 성능 - UUID

> UUID는 Random 데이터이기 때문에 삽입 시 이 값을 기준으로는 정렬이 되어있지 않다.

일단 primary key값을 관점으로 볼 때는 굉장히 mess된 테이블이다.

- **랜덤 삽입 문제 + 디스크 I/O 비용 증가** 
	- `UUID`는 무작위로 생성되므로, 새로운 레코드를 삽입할 때 디스크 페이지의 임의의 위치에 삽입될 가능성이 높다. 
	- 이로 인해 페이지 분할이 자주 발생하고, 데이터가 디스크 전체에 분산되어 저장되므로 **랜덤 I/O**가 증가합니다. 이는 **순차적 디스크 접근에 비해 훨씬 느린 작업**
- **메모리 캐싱 비효율** 
	- UUID를 기본키로 사용할 경우 Random 특성 때문에 Heap안에서 이리저리 이동하게 될 것이고, 데이터베이스가 이 행들을 삽입할 때 수행하는 **메모리 캐싱의 이점을 얻지 못할 것**
	- MySQL같은 '기본 키'기반 데이터베이스에서는 이런 한계가 있음 
- **정렬 이점 상실**
	- 일반적으로 클러스터링 인덱스는 연속적인 값(예: 자동 증가하는 숫자)으로 정렬되어 있을 때 성능이 좋지만, UUID는 연속적인 값이 아니므로 정렬의 이점을 잃게 됨

나중에 꼭 보기 : https://medium.com/@andrew_10845/databases-beyond-auto-increment-2101953fefc3

>[!tip] **MySQL과 UUID**
>- MySQL(InnoDB)은 기본적으로 Primary Key 기반의 클러스터링 데이터베이스이므로, `UUID`를 Primary Key로 사용하는 것은 특히 성능 저하를 야기할 수 있다. 
>- 이러한 이유로 Primary Key는 순차적인 값을 사용하는 것이 일반적인 권장 사항

> [!INFO] 보조 인덱스를 사용하지 않고 이러한 순차적인 클러스터링된 인덱스를 사용하는 것도 좋다(더 공부하면 딥해지니 PASS)


## 보조키 (Secondary Key)


### 보조 인덱스 

#### 1. 개념 
테이블의 물리적 데이터와는 별개로 존재하는 인덱스 구조
테이블이 뒤죽박죽인 상태로 있지만, **외부에 추가적인 구조**를 가지고 있는 것
- **별도의 구조**
	- 보조 인덱스는 **테이블 안에 있는 것이 아니다**. ❗❗
	- 인덱스는 테이블 자체에는 순서가 없지만, **다른 구조 내에서 정렬되어 있다.**
	- 즉, 인덱스를 위한 **별도의 구조(주로 B-트리)** 를 유지하고 있다는 것
	  
- **인덱스 내용**
	- 인덱싱된 컬럼의 값 + 해당 값이 속한 행의 물리적 주소(row id or pk)를 저장 

#### 2. 작동 방식

> 보조 인덱스도 인덱스다. 따라서 Index Scan의 기본 구조인 'Double Looup'방식으로 작동

1. **인덱스 검색** 
	- 디스크에 따로 존재하는 인덱스 파일에서 **TID(Tuple ID) 목록**을 먼저 얻는다
	- Note : Tuple ID에는 "**인덱스 키 값 + Page번호 + Offset**"을 갖고 있다.

2. **힙 접근** (2분 탐색 발생 - Double Lookup)
	- 인덱스에서 찾은 `Row ID`나 `Primary Key` 값을 사용하여 실제 행이 저장된 힙으로 다시 점프하여 데이터를 가져옴 
	
#### 3. 단점 

- **랜덤 I/O 발생 가능** (인덱스→힙으로 _무작위_ 점프)
	- 앞서 얻은 TID 하나마다, 실행기는 해당 블록을 버퍼에 읽어 **실제 행**을 확인
	- 행 수가 많을수록 **동일 블록을 여러 번 가져오는 상황**이 발생 ⛔

>[!warning] 즉, `SELECT *`와 같이 컬럼이 많거나, 조건이 별로 없을 때 랜덤 I/O가 급증 
>이때는 오히려 Seq Scan이 더 싸다.
>

>[!tip] 따라서, 컬럼이 적고 조건으로 필터링이 많이 일어날 때 인덱스를 사용하는 것이 좋다!!

#### 4. PostgreSQL의 보조 인덱스 
> PostgreSQL의 모든 인덱스는 보조 인덱스이다.

PostgreSQL은 기본적으로 물리적 클러스터링 인덱스를 지원하지 않는다. 
Primary Key를 설정하면 해당 필드에 대한 고유 인덱스가 자동으로 생성되지만, 이 인덱스 또한 보조 인덱스의 일종


Postgres에는 기본 인덱스가 없다.



IOT = Index Oraganized Table 
