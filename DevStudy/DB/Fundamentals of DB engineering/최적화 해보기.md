
### 이전 코드 
아래는 내가 맡은 배치 알림 생성을 위해 필요한 정보들을 가져오는 쿼리이다.
다른 팀원이 작성하였으며, 나는 그냥 이 메서드를 사용하기만 했다.
```JAVA 
  //특정시간 이후 등록된 모든 관심사-기사, 관심사별로 기사수를 가져옴  
  //관심사-유저와 위 테이블 조인  
  //유저-관심사-기사수를 구한다. -> 해당 엔티티마다 notification 전부 만들어야한다.  
  @Query(  
      "SELECT s.interest AS interest, s.user AS user, COUNT(ai) AS articleCount " +  
          "FROM Subscription as s " +  
          "JOIN ArticleInterest ai ON s.interest = ai.interest " +  
          "WHERE ai.createdAt > :afterAt " +  
          "GROUP BY s.interest, s.user"  
  )  
  List<UnreadInterestArticleCount> findNewArticleCountWithUserInterest(  
      @Param("afterAt") Instant afterAt);  
  
}
```

![[Pasted image 20250610130848.png]]

### 기존 코드의 문제
연관관계가 없는 JOIN이 일어났다 (ArticleInterest On Inter)



대규모 스캔, 불필요한 엔티티 로딩, 잘못된 시간 기준

|방법|쿼리 수|JOIN 수|메모리 사용량|
|---|---|---|---|
|**기존**|1개|3개|높음 (전체 엔티티)|
|**당신 제안**|N+1개|1개|중간|
|**한 방 쿼리**|1개|2개|낮음 (필요 컬럼만)|




일단 
```java
  
  public static NotificationJdbc create(UnreadInterestArticleCount unreadInterestArticleCount) {  
    Instant createdAt = Instant.now();  
    return NotificationJdbc.builder()  
        .id(UUID.randomUUID())  
        .userId(unreadInterestArticleCount.getUser().getId())  
        .resourceId(unreadInterestArticleCount.getInterest().getId())  
        .resourceType(ResourceType.INTEREST)  
        .content(  
            unreadInterestArticleCount.getInterest().getName() + "와/과 관련된 기사가 "                + unreadInterestArticleCount.getArticleCount()  
                + "건 등록되었습니다.")  
        .createdAt(createdAt)  
        .updatedAt(createdAt)  
        .confirmed(false)  
        .build();  
  }  
}
```
알림 생성로직은 다음과 같다.
보면 user관련 컬럼은 user ID만 필요.
즉, user 전체를 테이블에서 꺼내는건 매우 비효율적
userId만 index Only Scan을 사용하는 것을 권장 



```java 
@Service
public class NotificationBatchService {
    
    private final NotificationRepository notificationRepository;
    
    // 방법 1: 한 번의 쿼리로 모든 정보 조회
    public List<NotificationJdbc> createNotificationsFromNewArticles(Instant afterAt) {
        List<Object[]> results = notificationRepository.findNewArticleCountForNotification(afterAt);
        
        return results.stream()
            .map(NotificationQueryResult::from)
            .map(NotificationJdbc::create)
            .toList();
    }
    
    // 방법 2: 2단계로 나누어 처리 (대용량 데이터에 더 효율적일 수 있음)
    public List<NotificationJdbc> createNotificationsFromNewArticlesTwoStep(Instant afterAt) {
        // 1단계: 새 기사가 있는 관심사만 조회
        List<Object[]> interestResults = notificationRepository.findInterestsWithNewArticles(afterAt);
        
        if (interestResults.isEmpty()) {
            return Collections.emptyList();
        }
        
        List<UUID> interestIds = interestResults.stream()
            .map(row -> (UUID) row[0])
            .toList();
            
        // 2단계: 해당 관심사들의 구독자별 기사 수 조회
        List<Object[]> userResults = notificationRepository
            .findUserArticleCountByInterests(interestIds, afterAt);
            
        // 관심사 이름 매핑을 위한 Map 생성
        Map<UUID, String> interestNameMap = interestResults.stream()
            .collect(Collectors.toMap(
                row -> (UUID) row[0],
                row -> (String) row[1]
            ));
            
        return userResults.stream()
            .map(row -> new NotificationQueryResult(
                (UUID) row[0],  // user_id
                (UUID) row[1],  // interest_id
                interestNameMap.get((UUID) row[1]), // interest_name
                ((Number) row[2]).longValue() // article_count
            ))
            .map(NotificationJdbc::create)
            .toList();
    }
}
```


### 개선 방안 1. 한방 쿼리 

```JAVA 
@Query(value = """ 
		SELECT 
				ui.user_id,
				ui.interest_id, 
				i.name as interest_name, 
				COUNT(ai.article_id) as article_count 
		FROM articles_interests ai 
		JOIN users_interests ui ON ai.interest_id = ui.interest_id 
		JOIN interests i ON ui.interest_id = i.id 
		WHERE ai.created_at > :afterAt 
		GROUP BY ui.user_id, ui.interest_id, i.name
		""", nativeQuery = true) 
List<Object[]> findUserNotificationData(@Param("afterAt") Instant afterAt);
```

```SQL
CREATE INDEX idx_articles_interests_created_at ON articles_interests(created_at); CREATE INDEX idx_articles_interests_interest_created ON articles_interests(interest_id, created_at);
```


### 개선 방안 2. 여러방 쿼리 

> 핵심은 Interest이다 .

알림 객체 생성 로직을 다시 돌이켜보자. 
아래는 Srping-Batch에서 JDBC Insert를 위해 알림 객체를 생성하는 로직이다.
```java 
@Builder  
public record NotificationJdbc(  
    UUID id,  
    UUID userId,  
    UUID resourceId,  
    ResourceType resourceType,  
    String content,  
    Instant createdAt,  
    Instant updatedAt,  
    boolean confirmed) {  
  
  public static NotificationJdbc create(UnreadInterestArticleCount unreadInterestArticleCount) {  
    Instant createdAt = Instant.now();  
    return NotificationJdbc.builder()  
        .id(UUID.randomUUID())  
        .userId(unreadInterestArticleCount.getUser().getId())  
        .resourceId(unreadInterestArticleCount.getInterest().getId())  
        .resourceType(ResourceType.INTEREST)  
        .content(  
            unreadInterestArticleCount.getInterest().getName() + "와/과 관련된 기사가 "                + unreadInterestArticleCount.getArticleCount()  
                + "건 등록되었습니다.")  
        .createdAt(createdAt)  
        .updatedAt(createdAt)  
        .confirmed(false)  
        .build();  
  }
```

>[!tip] 정말 필요한게 뭐였을까??
>DB부하를 줄이고 인덱스를 극대화하기 위해서는 정말 필요한 컬럼들만 있으면 된다.
>1. 관련 기사 수 ⭐ 
>	- 여기서 크게 성능을 최적화 할 수 있는 부분이였다.
>	- 이전 : 당연히 관련 기사 수 이니 관련된 Article.count()를 이용하려 했다.
>	- 개선 : articles_interests테이블에서 interestsId에 맞는 article_id의 count만 따로 가져올 수 있다. 이렇게 되면 article 테이블을 조회하지 않아도 된다.
>2. Interest 
>	- 필요 컬럼 : id, name
>	- 필요 없는 컬럼 : keywords, createdAt
>	- 필요 없는 컬럼을 빼고 가져오는게 메모리 적으로도 좋고, 인덱스 활용면에서도 더 좋아 보인다.
>	  
>3. User
>	- 필요 컬럼 : id
>	- 생성된 article가 관련된 Interest를 가지고 있는 user의 id 
>	- 


핵심은 Interest ⭐⭐
- Interest에 맞는 기사 수 
- Interest를 갖고 있는 user Id
- 그리고 그냥 Interest 그 자체 


1. articles_Interests 테이블에서 생성된 기사의 id와 그에 맞는 
2. 1번에서 얻은 id를 가지고 interest의 name 조회 
3. 



| 정류장 | 1   | 2   | 3   | 4   | 5   |
| --- | --- | --- | --- | --- | --- |
| 충전지 | 2   | 3   | 1   | 1   |     |
