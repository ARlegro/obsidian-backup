
개발 리포트는 프로젝트가 끝난 후 전체적인 과정을 되돌아보고, 성과와 문제 해결 과정을 정리하여 팀과 공유하는 문서입니다. 프로젝트의 전반적인 진행 상황, 맡은 역할, 해결한 문제 등을 구체적으로 기술하여 향후 프로젝트에 대한 참고자료로 활용할 수 있습니다.

## **개발 리포트 작성 항목**

### **1. 프로젝트 개요**

- 프로젝트의 목적과 핵심 기능을 간단히 설명해 주세요.

### **2. 담당한 작업**

> 프로젝트 내에서 본인이 맡은 역할과 기여한 부분을 구체적으로 기술해 주세요.

- Spring Batch 기반 뉴스 기사 수집 및 알림 자동화
- AWS S3를 통한 기사 백업 및 복구 프로세스 구현
- 알림 자동 삭제 배치 및 Spring Actuator로 모니터링

### **3. 기술적 성과**

> 프로젝트에서 사용한 기술 스택과 구현한 주요 기능을 설명해 주세요.

**✅기술 스택** 
- 스프링 배치 

**✅구현한 주요 기능** 

S



### **4. 문제점 및 해결 과정**

- 프로젝트 진행 중 직면한 기술적 문제와 이를 해결한 과정을 상세히 설명해 주세요.
    - 예시: "초기에 데이터베이스 마이그레이션 과정에서 테이블 구조 변경으로 인해 데이터 충돌이 발생했습니다. 이를 해결하기 위해 기존 데이터를 백업한 후 새로운 스키마로 마이그레이션을 성공적으로 완료했습니다."

### **5. 협업 및 피드백**

> 팀원들과의 협업 과정에서 느낀 점, 배운 점, 그리고 피드백을 기록해 주세요.

✅협업 



✅ 피드백 
개인적으로 이번 프로젝트를 하면서 중간에 개발과 관련된 외부 일정이 여러개 생기다보니 프로젝트 중간부터 몰입을 못하게 되어서 아쉬웠습니다.
그러다보니 개선할만한 포인트들을 인지하면서도 못하고 있는 점과 팀원들과의 소통이 아쉬웠던 것 같습니다.

### **6. 코드 품질 및 최적화**

>프로젝트 중 코드의 가독성과 유지보수성을 어떻게 고려했는지, 성능 최적화를 위한 작업을 설명해 주세요.

**✅유지 보수성 어떻게 고려?**

**1‍⃣ 일급 컬렉션과 비슷한 객체 사용**
```java
@Slf4j  
@Component  
public class InterestContainer {  
  
  private final List<Interest> interests = new ArrayList<>();  
  private final Set<String> sourceUrlFilterSet = ConcurrentHashMap.newKeySet();

  (필터링 기능)
	public ArticleApiDto filter(ArticleApiDto articleApiDto) {  
			if (isContainKeywords(articleApiDto.summary()) && ~~~ ) 
    return articleApiDto;  
  }
  ... 
  
  (관련된 Interest 매칭 후 변환 기능)
	public ArticleWithInterestList toArticleWithRelevantInterests(ArticleApiDto articleApiDto) {
```
- `InterestContainer`는 단순 컬렉션이 아니라, 필터링, 매핑, 관련 데이터 추출 로직을 캡슐화한 객체입니다.
- DB로부터 `Interest` 목록과 관련 URL을 가져와 이 객체로 초기화하며, 데이터와 그에 수반되는 **도메인 로직을 함께 관리**할 수 있도록 설계했습니다.
- 물론, 하나의 컬렉션만 포함하지는 않기 때문에 일급컬렉션은 아니지만, 일급 컬렉션의 철학인 불변성 유지, 책임 부여, 캡슐화를 따라 설계했습니다.
- 효과 : 응집도, 안정성, 유지보수성 상승 + 책임 부여
 

**2‍⃣ 컨텍스트 저장 ➡ 싱글톤 패턴 적용** 
참고 : https://myvelop.tistory.com/235

**초기 - 단순 batch Context사용** 
- 기사관련 배치작업을 할 때 Component가 아닌 pojo객체로 ExecutionContext에 저장해서 다른 Step과 공유를 했었습니다.
- 하지만 batch Context를 이용하는 것에는 몇가지 단점이 있습니다
	1. 직렬화 비용 : JSON ↔ String 변환 비용 大
	2. 타입 안정성 떨어지는 문제 : 직렬화를 통한다면 null 값 오류가 나올 수도 있고, Context에 집어넣거나 가져올 시 문자열로 직접 작성해야한다는 단점이 있습니다.
```java 
	@Value("#{jobExecutionContext['hankyungArticleDtos']}")`
```


**이후 - 스레드 안정적인 Singleton 객체** 
- 배치에서 Singleton을 사용하면 데이터가 오염될 위험이 있습니다.
- 하지만 이 문제는 스레드 안정적인 객체에는 크게 해당하지 않는 객체로 잘만 하면 성능적으로 이점을 얻을 수 있습니다.
- 이를 위해 일부 변하는 부분만 Concurrent 자료규조를 만들어 SIngleton 객체를 공유하고 Job이 끝나면 bean을 정리하는 방식을 사용했습니다.
```java
@Slf4j  
@Component  
public class InterestContainer {  
  
  private List<Interest> interests = new ArrayList<>();  
  private final Set<String> keywords = ConcurrentHashMap.newKeySet();  
  private final Set<String> sourceUrlFilterSet = ConcurrentHashMap.newKeySet();  
  
  public void register(List<Interest> interests, List<String> sourceUrls) {  
    clearBean();  
    this.interests = interests;  
    this.interests.stream()

```




**3‍⃣ 결합도 줄이기**

```java
[결합도 줄이기 전]
public static ArticleInterestJdbc create(Article article, Interest interest) {  
  UUID id = UUID.randomUUID();  
  return new ArticleInterestJdbc(  
      id,  
      article.getArticleId,  
      interest.getInterestId,  
      Instant.now()  
  );  
}


[결합도 줄인 후]
public static ArticleInterestJdbc create(UUID articleId, UUID interestId) {  
  UUID id = UUID.randomUUID();  
  return new ArticleInterestJdbc(  
      id,  
      articleId,  
      interestId,  
      Instant.now()  
  );  
}
```
- 초기 : Article, Interest 객체를 그대로 넘겨 그 객체들의 일부 필드만 활용했습니다.
- 문제점 : 불필요한 정보와 결합도 증가 문제 
- 개선 : 객체, 자료구조를 파라미터로 통째로 넘기는 스탬프 결합도에서 자료 결합도로 바꿈으로써 결합도를 낮추고 리팩토링 및 확장 용이한 코드로 개선해봤습니다.

  
**4‍⃣ 무리한 inline 지양, 의도 명시로 가독성 확보** 

**과거**
- inline variable을 최대한 활용해 코드를 줄이는 것을 선호했습니다.
- 하지만 유지보수성과 명시성을 고려하여 코드 스타일을 바꾸려고 노력했습니다.

**이번 프로텍트**
- 메서드 분리와 메서드명을 통해 코드가 조금 길어지더라도 의도를 명확히 하려고 노력했습니다.
- 또한 의도를 명확히 드러내는 변수를 만들기 위해 inline variable 사용을 지양했습니다.
- 가령, 아래 코드에서 .key() 부분에 String.format 코드를 바로 넣어도 되지만, 이렇게 분리함으로써 가독성 및 의도파악을 명시하고 유지보수성을 높이는 식으로 코드를 잤습니다.
```java
LocalDateTime now = LocalDateTime.now();  
String s3Path = String.format("%s/%s.csv", now.toLocalDate(), now.getHour());  
PutObjectRequest putObjectRequest = PutObjectRequest.builder()  
    .key(s3Path)
```



**5‍⃣ JpaWriter ➡ JdbcWriter**

```java
[JdbcWriter]
@Bean  
@StepScope  
public JdbcBatchItemWriter<Article> articleJdbcItemWriter() {  
  
  String articleInsertSql =  
      "INSERT INTO articles (id, source, source_url, title, publish_date, summary, deleted) "  
          + "VALUES (?, ?, ?, ?, ?, ?, ?)";  
  
  return new JdbcBatchItemWriterBuilder<Article>()

```

**💢JpaWrtier의 문제**
- 초기에는 JpaItemWriter를 사용해 데이터를 저장하는 로직을 짰습니다.
- 하지만, 이는 bulk연산이 안돼 대규모 처리를 위해서는 적합하지 않다고 생각했습니다.
- 또한, 타 팀의 중간 발표에서 발견된 락관련 문제도 있던 것으로 발견됐습니다.

**✅JdbcWriter로 개선** 
- JpaWriter의 단점을 보완하고자 처음에는 배치가 제고하는 구현체들을 커스텀하려고 했으나 시간이 많이 부족해서 간단히 JdbcWriter로 개선했습니다.
- Jdbc는 bulk연산을 제공하기 때문에 처리 시간이 눈에 띄게 줄어드는 효과가 있었습니다.



**6‍⃣ 배치에서 step끼리 자원 공유 시 더 우아하게 - PromotionListener**
- 배치에서 step끼리 자원을 공유하는 방법에는 3가지가 있습니다.
	1. jobContext에 저장하기 ⬅ 기존에 쓰던 방식
	2. Singleton 객체 사용하기
	3. **stepContext에 저장 후 PromotionListener 사용하기 ✅최적** 

1 ➡ 3 으로 바꾼 이유 
- JobContext에 바로 저장하지 말아야 되는 이유 
	- 유실 위험 : Step이 중간에 실패하면 데이터가 유실될 위험이 있다.
	- 결합도 : Step이 해당 Job에 강하게 결합되어 재사용하기 어려워진다.
- 3번 방식은 스프링 공식 레퍼런스에서 추천하는 것으로 코드가 길어질 수는 있지만 job과의 결합도를 낮추고 안전한 방식입니다.

### **7. 향후 개선 사항 및 제안**

**✅개선할 수 있는 부분**
1. **알림 생성 위한 DB조회 시 Chunk 프로세싱** 
	- 알림 생성을 위해 DB에서 필요한 정보들을 가져오는 부분에서 Chunk단위로 작업을 할 수 있는 부분들이 있었습니다.
	
2. **백업 로직 시 방식 변경** 
	- 현재 : 백업 시 로컬에 백업 후 FlatFileItemWriter를 사용해 S3에 백업
	- 개선 : 로컬 백업 없이 Multiupload 방식 구현 

3. **알림 생성을 위해 가져온 DTO부분에서 결합도 낮추는 설계**
	- 현재 : `unReadInterest~~` 부분의 객체 전체를 파라미터로 전달 후 처리
	- 개선 : 필요한 데이터만 파라미터로 넘겨 결합도를 낮추기 (스탬프 결합도 ➡ 자료 결합도)

4. **액츄에이터 + 프로메테우스 + 그라파나를 통한 배치 추적 커스텀**
	- 초창기에 위의 3가지를 세팅하며 배치 관련 그라파나 대시보드를 세팅하려 했으나, 단순 메서드, 클래스가 아니라 빈형태+배치 라는 점 때문에 쉽게 손대지 못했습니다.
	- 만약, 시간이 남는다면 가장 해보고 싶은 개선 부분입니다.
5. **JdbcWriter 개선 포인트1.** `CompositeItemWriter` 사용해서 로직을 더 깔끔하게 구성
6. **JdbcWriter 개선 포인트2.** 커스텀하기 : 시간이 많이 소요되는 작업
7. **직렬화 오류 체크 관련 로직 추가** 
8. **Chunk 부분 예외 설계** 


## **평가 기준**

개발 리포트는 프로젝트에 대한 종합적인 평가를 위한 중요한 자료입니다. 다음 항목들이 평가됩니다

- 프로젝트에 대한 기여도 및 성과
- 문제 해결 능력 및 기술적 역량
- 팀원들과의 협업 및 피드백 반영
- 작성한 코드의 품질, 효율성, 유지보수 용이성

이 가이드를 토대로 리포트를 작성하시면, 프로젝트의 성과와 경험을 명확하게 정리할 수 있습니다.

## **개발 리포트 작성 시 참고 사항**

- 프로젝트를 진행하시면서 주말 내 틈틈이 개발 리포트를 작성하는 것을 권장드립니다.
- 본인이 **잘했다고 생각하는 PR 링크**나 **코드 리뷰 링크**를 꼭 포함해 주세요.
- 개발 리포트 작성 시 STAR 기법을 활용하면 프로젝트의 상황과 문제 해결 과정을 체계적으로 정리할 수 있습니다.

### **START 기법이란?**

STAR 기법은 상황(Situation), 과제(Task), 행동(Action), **결과(Result)**의 네 단계를 통해 각 항목을 구체적으로 설명하는 방법입니다.

1. 상황 (Situation): 문제가 발생한 상황이나 프로젝트 배경을 설명하세요.
2. 과제 (Task): 그 상황에서 해결해야 했던 과제나 목표를 구체적으로 기술하세요.
3. 행동 (Action): 문제 해결을 위해 어떤 행동을 취했는지, 구체적인 방법과 과정에 대해 서술하세요.
4. 결과 (Result): 그 행동의 결과로 얻은 성과나 배운 점을 설명하세요.