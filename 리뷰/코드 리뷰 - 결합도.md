[[모듈]]

정보처리기사를 공부하다가 객체 지향, 모듈에 관한 부분이 나와서 이전 프로젝트에서 해왔던 코드들을 되돌아 보는 시간을 가졌다.
결합도와 응집도 이 2가지 부분을 공부하면서 내 코드의 결함이 많이 느껴졌다.


### 리팩토링 : 스탬프 결합도 ➡ 자료 결합도 
#### 예시 1. 

**결합도가 존재하는 코드 - 스탬프 결홥도**
```java
public record ArticleInterestJdbc(  
    UUID id,  
    UUID articleId,  
    UUID interestId,  
    Instant createdAt) {  
  
  public static ArticleInterestJdbc create(Article article, Interest interest) {  
    UUID id = UUID.randomUUID();  
    return new ArticleInterestJdbc(  
        id,  
        article.getId(),  
        interest.getId(),  
        Instant.now()  
    );  
  }
```
이 코드는 객체를 파라미터로 통쨰로 전달한 코드이다.
create() 메서드는 Article 객체의 id, Interest객체의 id만들 사용하는데 객체 전체를 파라미터로 전달받았다.

이러한 형태의 결합도를 스탬프 결합도 라고 한다.
모듈의 6단계 결합도 중 2번쨰로 좋은 결합도이긴 하지만, 최고로 좋은 것은 아니다.
즉, 아직 더 리팩토링할 점이 있다는 것이다.

> 리팩토링 해보자 

**결합도를 없앤 코드 - 자료 결합도**
```java
public static ArticleInterestJdbc create(UUID articleId, UUID interestId) {  
  UUID id = UUID.randomUUID();  
  return new ArticleInterestJdbc(  
      id,  
      articleId,  
      interestId,  
      Instant.now()  
  );  
}
```
파라미터로 정말 필요한 데이터밖에 없다.
즉, **모듈간의 인터페이스가 자료 요소로만 구성**되게 함으로써, 다른 모듈에 영향을 주지 않는 결합도이다.
이는 재사용성, 확장성, 리팩토링 내성에 강한 코드로 만들어준다.


#### 예시2. 

예시1 이랑 똑같은 경우다.
사실 객체를 전부 넘길 필요가 없다는 것을 알면서도 람다식(::)을 사용하고 싶어서 억지로 만들었었는데, 가독성보다 결합도를 낮추는게 더 중요한 것 같아서 바꾸는 것이 좋을 것 같다.

**스탬프 결합도** 
```java
  
  public static NotificationJdbc create(UnreadInterestArticleCount unreadInterestArticleCount) {  
    Instant createdAt = Instant.now();  
    return NotificationJdbc.builder()  
        .id(UUID.randomUUID())  
        .userId(unreadInterestArticleCount.getUser().getId())  
        .resourceId(unreadInterestArticleCount.getInterest().getId())  
        .resourceType(ResourceType.INTEREST)  
        .content(  
            unreadInterestArticleCount.getInterest().getName() + "와/과 관련된 기사가 "                + unreadInterestArticleCount.getArticleCount()  
                + "건 등록되었습니다.")  
        .createdAt(createdAt)  
        .updatedAt(createdAt)  
        .confirmed(false)  
        .build();  
  }  
}
```


**자료 결합도** 
```java
public static NotificationJdbc create(UUID userId, Interest interest, Long articleCount) {  
  Instant createdAt = Instant.now();  
  return NotificationJdbc.builder()  
      .id(UUID.randomUUID())  
      .userId(userId)  
      .resourceId(interest.getId())  
      .resourceType(ResourceType.INTEREST)  
      .content(  
          interest.getName() + "와/과 관련된 기사가 "              + articleCount  
              + "건 등록되었습니다.")  
      .createdAt(createdAt)  
      .updatedAt(createdAt)  
      .confirmed(false)  
      .build();  
}
```


### 최악의 결합도 - 3달전의 나에게 

> 결합도의 6단계 중 최악은 `내용 결합도`  이다 `

이는, 한 모듈이 다른 모듈의 내부 구현, 자료를 직접 참조하는 것으로 아래와 같다.

```java
// 내부 필드에 직접 접근 (비추천)
class A {
    public int secret = 42;
}

class B {
    public void doSomething(A a) {
        a.secret = 999;  // A의 내부 구현에 직접 의존
    }
```
A의 구현이 바뀌면 B도 수정해야 됨
이는 유지보수에 최악 

>[!QUESTION] 왜 리뷰글에 이거를???
>3달전의 나는 멘토님 리뷰 시간에 엔티티 클래스가 DTO를 알면 안된다고 리뷰를 받고, 별 생각 없이 아 그렇구나~ 라고 생각하며 코드를 짰었다.
>하지만 모듈의 최악의 결합도를 보면서 이 경우를 말하는 것이다라고 느꼈다. 이전에는 그냥 받아들였던 개념을 결합도의 관점에서 보니 최악의 코드였던 것을 느꼈다.
>Cuz DTO는 스펙이 자주 바뀔텐데, 그럴때마다 엔티티 클래스를 바꿔야하는 문제가 발생


--- 
## 결합도와 응집도 : 참고 
### 결합도 ⭐⭐⭐⭐
- 서로 다른 두 모듈 간의 상호 의존도
- 낮을수록 독립성이 향상되어 유지보수 작업이 용이
- 자료 결합도가 설계 품질이 가장 좋다

#### 결합도의 6단계 ⭐**⭐**

> 낮은 순서 

`자 - 스 - 제 -외 - 공 - 내` 

##### ✅**1. 자료 결합도** **(가장 낮은)** **- 데이터 결합도** 
- 모듈 간의 인터페이스가 자료 요소로만 구성된 경우로, 다른 모듈에 영향을 주지 않는 결합도 
- 가장 바람직한 결합도로 결합도가 매우 약하다 
- 모듈 간의 내용을 전혀 알 필요가 없다
```java
public void process(String productName, int quantity) {
		System.out.println(productName + " x " + quantity);
}
```
- 의존 최소화, 변경에 강함


##### **스탬프 결합도** (두번째로 낮은)
- **두 모듈이 같은 자료 구조를 조회**하는 경우의 결합도
- 자료 구조의 어떠한 변화가 그것을 조회하는, 조회하지 않는 모듈까지도 영향을 미친다.
- ex. 객체, 배열, 레코드를 통째로 전달 
```java
public class Order {
    public String productName;
    public int quantity;
}

public class OrderService {
    public void process(Order order) {
        System.out.println(order.productName);
    }
}```
- 그래도 6단계 중 2번째로 결합도가 낮긴한데,
- productName만 필요한데 필요없는 객체를 받았다.
- 이는 구조 변경에 취약한 구조이다.

> [!INFO] 스탬프 결합도 vs 자료 결합도 쉽게 구분 
> 스탬프 결합도 ➡ `자료 구조`를 전달 
> 자료 결합도 ➡ `자료 요소`를 전달

##### **제어 결합도** 
- 한 모듈이 다른 모듈의 처리 흐름(제어)에 간섭 ex. boolean
```java
public void print(String msg, boolean upper) {
		if (upper) System.out.println(msg.toUpperCase());
		else System.out.println(msg.toLowerCase());
}
```

##### 외부 결합도 
- 두 모듈이 외부 시스템, 파일 포멧 등에 의존 
- 외부 시스템-파일 포맷이 바뀌면 모듈이 실패
- 즉, **외부 변화에 민감한 구조**이다.
```java
public void parse(String filePath) throws IOException {
		// 특정 형식의 외부 파일을 가정 (예: CSV)
		BufferedReader reader = new BufferedReader(new FileReader(filePath));
```


##### 공통 결합도 
- 전역 변수를 공유하는 예
- 어떤 모듈이 전역변수를 바꾸면 다른 모듈도 영향을 받는 구조 


##### 최악 : 내용 결합도 
한 모듈이 다른 모듈의 내부 구현, 자료를 직접 참조

```java
// 내부 필드에 직접 접근 (비추천)
class A {
    public int secret = 42;
}

class B {
    public void doSomething(A a) {
        a.secret = 999;  // A의 내부 구현에 직접 의존
    }
```
A의 구현이 바뀌면 B도 수정해야 됨
이는 유지보수에 최악 


### 응집도 ⭐⭐⭐

#### 개념 
- 얼마나 관련이 높은 요소끼리 모여있는지 
- 모듈이 독립적인 기능으로 구성됨의 정도를 의미 
- 응집도가 높다 ➡ 필요한 요소들로만 구성되었다는 의미
- 응집도가 낮다 ➡ 요소 간의 관련성이 적다

#### 단계 

> 높은 순서 - 높을수록 좋은 것 
##### **기능적 응집도** **(BEST)**
- 모듈 내부의 **모든 기능들이 한 문제와 연관되어** 수행되는 경우 
- 하나의 목적을 위해 메서드/모듈이 최적화 되어 있다
- 이는 확장/테스트/재사용 모두 굿 

##### **순차적 응집** 
- 모듈 내의 **한 기능의 작업의 결과가** **다른 기능의 작업의 입력 자료로 제공** 된다.
- 작업 흐름이 유기적으로 연결됨 
```java
void process(String jsonOrder){
		Order order = parse(jsonOrder);
		process(Order);
		send(Order)
}
```
- Order의 프로세스를 실행시키기 위해 parser 작업을 하는 

##### **교환적(통신적) 응집** 
- **같은 자료 구조를 사용**해서 처리하는 구조 
```java
public void process(User user){
		validate(User)
		save(User)
		notify(User)
}
```
- **공통 데이터로 연관성**을 확보 할 수 있다.

##### 절차적 응집 
- 순서상 연관된 작업이지만, **데이터는 공유하지 않는** 경우
- 데이터를 공유하지 않는다는 점에서 순차적 응집과 비교 
```java
public void processPayment() {
    verifyCard();
    updateLedger();
    sendReceipt();
}
```
- 교환적 응집과 비슷해보이지만 절차적 응집은 데이터도 공유 안하는 수준이다.

##### 시간적 응집 
- 같은 시점에 실행되는 작업들의 묶음 
```java
void init(){
	login()
	reset()
	create()
}
```
- 시점은 같지만, **논리적 관련은 적다**


##### 논리적 응집 
- 여러 기능 중 하나를 모듈 내에서 조건문으로 분기해서 처리 
- 이는 테스트에 어려움을 유발 


##### 우연적 응집 (Worst) ⭐
메서드 간 연관성 없는 것들을 같은 클래스에 넣어 놓은 예시 
재사용, 유지보수에 최악 


### 모듈 설계의 특징 

> 응집도는 강하게, 결합도는 약하게  -> 모듈의 독립성을 확보 

- 위의 기본 원칙을 지키며, 유지 보수를 수월하게 하기
- 모듈 간의 접속 관계를 분석하여 복잡도와 중복을 피하려 노력하기
- 계층적 자료 조직 제시 
