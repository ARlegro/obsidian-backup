
### 분류 

1. 선형구조 
	- 리스트 - 선형, 연결 리스트
	- 스택
	- 큐
	- Deque
	  
2. 비선형구조 
	- 트리
	- 그래프


### 자료 구조의 활용 

> 자료 구조로 무엇을 할 수 있을까??

1. 정렬
2. 검색
3. 인덱스(Index) ⭐
	- DB에서 데이터를 빨리 검색할 수 있도록 도와주는 것 
	- 데이터의 성능을 좌우한다 
	- 활용 방법
		- 인덱스 테이블을 만들어 데이터의 위치를 일목요연하게 정리해 놓은 것 
4. 파일 편성
	- 파일에서 레코드의 물리적 배열 방법


### 선형 자료 구조 

리스트 - 선형, 연결 리스트 

#### 스택  ⭐

- 리스트의 한쪽 끝에서만 자료의 삽입과 삭제가 이루어 지는 자료 구조 
- 후입 산출 
- 0-주소 인스트럭션
- **스택 가드** ⭐⭐
	- 스택에서, return 주소와 buffer 사이에 특정 값을 삽입하여 이 값이 함수 리턴 전에 변경되었는지를 확인한다.
	- 만약, 리턴값이 알고 있는 값과 다르면 오버플로우 상태로 가정하여 프로그램 실행을 중단한다.

#### 데크(Deque)

- 자료의 삽입,삭제가 리스트의 양 끝에서 이루어진다.
- 스택 + 큐 의 복합 형태 



### 비선형 자료 구조 

#### 트리 

트리 관련 용어들 중 대부분은 JS 에서 배운 노드 개념이다.
몇 개 외울만한 것 
- 깊이(Depth) : 트리의 최대 레벨 
- **차수**(Degree) : 어떤 노드에 연결된 자식 노드의 수  ⭐
- **단말 노드** : 트리의 제일 마지막에 위치한 노드 수 ⭐⭐
- **트리의 차수** : 트리 노드 중 가장 큰 차수


#### 이진 트리 

- 차수가 2이하인 노드들로 구성된 트리 
- 구조 
		![[Pasted image 20250507153501.png]]


 


> [!INFO] 수식의 표기법 
> ![[Pasted image 20250507154319.png]]

![[Pasted image 20250507154416.png]]


#### 그래프 

- 트리가 연결되어 있는 
- 점점과 간선의 집합으로 이루어진 자료구조 
- **인접 행렬  ⭐**
	- 

> [!INFO] n개의 노드로 구성된 무방향 그래프의 최대 간선수 
> - n(n-1) / 2


### 정렬 

2가지 종류가 있다.
1. 내부 정렬 
	- 주 기억 장치(ex. 메모리)에서 정렬이 이루어짐 

2. 외부 정렬 
	- 보조 기억 장치(디스크)에서 정렬이 이루어짐 
	- 정렬할 데이터가 너무 커서 외부에서 일부씩 불러와 처리 

#### 삽입 정렬 

> 앞에서부터 하나씩 꺼내서, 정렬된 영역에 끼워 넣는 방식 

**☑ 정렬 과정 예시**

정렬 대상: `[5, 3, 4, 1, 2]`
1. 시작: `| 5 |` `3 4 1 2` → 5는 혼자니까 정렬된 상태
2. 3을 5 앞에 끼움 → `| 3 5 |` `4 1 2`
3. 4는 5 앞에 끼움 → `| 3 4 5 |` `1 2`
4. 1은 맨 앞으로 → `| 1 3 4 5 |` `2`
5. 2는 3 앞에 → `| 1 2 3 4 5 |`

**☑특징** 
- 거의 정렬된 데이터일수록 좋음 
- 시간 복잡도 
	- 최선 : O(n)
	- 평균/쵱가 : O(n2)

#### 버블 정렬

> 이웃한 두 값을 비교하면서 자리를 바꿔가며, 가장 큰 수가 점점 뒤로 가는 방식 
> - 여러 번 회전 

**☑특징** 
- 시간 복잡도 : O(n2)
- 단순하지만 **비효율적** 

#### 선택 정렬 ⭐

> 가장 작은 값을 골라서, 현재 위치의 값과 교환 


**☑예시**

정렬 대상: `[5, 3, 4, 1, 2]`
1. 전체 중 최소 `1` 선택 → `1 <-> 5` → `[1, 3, 4, 5, 2]`
2. 나머지 중 최소 `2` 선택 → `2 <-> 3` → `[1, 2, 4, 5, 3]`
3. 최소 `3` → `3 <-> 4` → `[1, 2, 3, 5, 4]`    
4. 최소 `4` → `4 <-> 5` → `[1, 2, 3, 4, 5]`

**☑특징** 
- 항상 `n(n-1)/2`번 비교 → **시간복잡도 O(n²)**
- 버블보다는 효율적
- 삽입보다는 느림 



- 평균 시간복잡도가 O(n2) ➡ 시간이 많이 걸린다

#### 병합(합병) 정렬


☑ 예싱 

정렬 대상: `[5, 3, 4, 1, 2]`

[5, 3, 4, 1, 2]

→ 반으로 나눔
[5, 3]       [4, 1, 2]

→ 계속 나눔 
[5]  [3]     [1]  [4]  [2]  

→ 정렬하며 병합 
[3, 5]       [1, 4] + [2] 

→ [3, 5]     [1, 2, 4] 

→ 최종 병합
[1, 2, 3, 4, 5]

**☑시간복잡도** 
	- 항상 일정하게 log n 단계로 n번 합침 ➡ n log n 
	- 일정한 성능 
	- 물론 n log n 이라는게 뒤로 갈수록 가파르게 복잡도 올라감 

#### 퀵 정렬 

> 분할 정복 방식의 정렬, **빠른 정렬 중 하나** 

☑특징
- 피벗을 기준으로 데이터를 작은 값/ 큰 값으로 분할 

☑시간복잡도 
- 최악 : O(N2)
- 최대,최소,평균 : O(n log n)


#### 힙 정렬 

>ㅇ

- 전이진 트리를 이용하여 정렬 
- 시간복잡도
	- 평균 : O(n log2 n)
	- 최악 : O(log2 n)


