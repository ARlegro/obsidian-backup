모듈 = 하나의 기능을 하는 작은 코드의 집합?


### 개념 
전체 프로그램에서 어떠한 기능을 수행할 수 있는 실행 코드를 의미 


✔특징 
**재사용 가능** 
**자체 컴파일 가능**  
⭐모듈은 **독립성이 높을수록 좋다**. 이는 **결합도**와 **응집도**에 의해 측정된다.

> 재사용, 자체 컴파일, 독립성이 핵심 


### 결합도 ⭐⭐⭐⭐
- 서로 다른 두 모듈 간의 상호 의존도
- 낮을수록 독립성이 향상되어 유지보수 작업이 용이
- 자료 결합도가 설계 품질이 가장 좋다

#### 결합도의 6단계 ⭐**⭐**

> 낮은 순서 

`자 - 스 - 제 -외 - 공 - 내` 

##### ✅**1. 자료 결합도** **(가장 낮은)**
- 모듈 간의 인터페이스가 자료 요소로만 구성된 경우로, 다른 모듈에 영향을 주지 않는 결합도 
- 가장 바람직한 결합도로 결합도가 매우 약하다 
- 모듈 간의 내용을 전혀 알 필요가 없다
```java
public void process(String productName, int quantity) {
		System.out.println(productName + " x " + quantity);
}
```
- 의존 최소화, 변경에 강함


##### **스탬프 결합도** (두번째로 낮은)
- 두 모듈이 같은 자료 구조를 조회하는 경우의 결합도
- 자료 구조의 어떠한 변화가 그것을 조회하는, 조회하지 않는 모듈까지도 영향을 미친다.
- ex. 객체, 배열, 레코드를 통째로 전달 
```java
public class Order {
    public String productName;
    public int quantity;
}

public class OrderService {
    public void process(Order order) {
        System.out.println(order.productName);
    }
}```
- 그래도 6단계 중 2번째로 결합도가 낮긴한데,
- productName만 필요한데 필요없는 객체를 받았다.
- 이는 구조 변경에 취약한 구조이다.

##### **제어 결합도** 
- 한 모듈이 다른 모듈의 처리 흐름(제어)에 간섬 ex. boolean
```java
public void print(String msg, boolean upper) {
		if (upper) System.out.println(msg.toUpperCase());
		else System.out.println(msg.toLowerCase());
}
```

##### 외부 결합도 
- 두 모듈이 외부 시스템, 파일 포멧 등에 의존 
- 외부 시스템-파일 포맷이 바뀌면 모듈이 실패
- 즉, **외부 변화에 민감한 구조**이다.
```java
public void parse(String filePath) throws IOException {
		// 특정 형식의 외부 파일을 가정 (예: CSV)
		BufferedReader reader = new BufferedReader(new FileReader(filePath));
```


##### 공통 결합도 
- 전역 변수를 공유하는 예
- 어떤 모듈이 전역변수를 바꾸면 다른 모듈도 영향을 받는 구조 


##### 최악 : 내용 결합도 
한 모듈이 다른 모듈의 내부 구현, 자료를 직접 참조

```java
// 내부 필드에 직접 접근 (비추천)
class A {
    public int secret = 42;
}

class B {
    public void doSomething(A a) {
        a.secret = 999;  // A의 내부 구현에 직접 의존
    }
```
A의 구현이 바뀌면 B도 수정해야 됨
이는 유지보수에 최악 


### 응집도 ⭐⭐⭐

#### 개념 
- 얼마나 관련이 높은 요소끼리 모여있는지 
- 모듈이 독립적인 기능으로 구성됨의 정도를 의미 
- 응집도가 높다 ➡ 필요한 요소들로만 구성되었다는 의미
- 응집도가 낮다 ➡ 요소 간의 관련성이 적다

#### 단계 

> 높은 순서 - 높을수록 좋은 것 
##### **기능적 응집도** **(BEST)**
- 모듈 내부의 **모든 기능들이 한 문제와 연관되어** 수행되는 경우 
- 하나의 목적을 위해 메서드/모듈이 최적화 되어 있다
- 이는 확장/테스트/재사용 모두 굿 

##### **순차적 응집** 
- 모듈 내의 **한 기능의 작업의 결과가** **다른 기능의 작업의 입력 자료로 제공** 된다.
- 작업 흐름이 유기적으로 연결됨 
```java
void process(String jsonOrder){
		Order order = parse(jsonOrder);
		process(Order);
		send(Order)
}
```
- Order의 프로세스를 실행시키기 위해 parser 작업을 하는 

##### **교환적(통신적) 응집** 
- **같은 자료 구조를 사용**해서 처리하는 구조 
```java
public void process(User user){
		validate(User)
		save(User)
		notify(User)
}
```
- **공통 데이터로 연관성**을 확보 할 수 있다.

##### 절차적 응집 
- 순서상 연관된 작업이지만, **데이터는 공유하지 않는** 경우
- 데이터를 공유하지 않는다는 점에서 순차적 응집과 비교 
```java
public void processPayment() {
    verifyCard();
    updateLedger();
    sendReceipt();
}
```
- 교환적 응집과 비슷해보이지만 절차적 응집은 데이터도 공유 안하는 수준이다.

##### 시간적 응집 
- 같은 시점에 실행되는 작업들의 묶음 
```java
void init(){
	login()
	reset()
	create()
}
```
- 시점은 같지만, **논리적 관련은 적다**


##### 논리적 응집 
- 여러 기능 중 하나를 모듈 내에서 조건문으로 분기해서 처리 
- 이는 테스트에 어려움을 유발 


##### 우연적 응집 (Worst)
메서드 간 연관성 없는 것들을 같은 클래스에 넣어 놓은 예시 
재사용, 유지보수에 최악 


### 모듈 설계의 특징 

> 응집도는 강하게, 결합도는 약하게  -> 모듈의 독립성을 확보 

위의 기본 원칙을 지키며, 유지 보수를 수월하게 하고 중복 및 복잡도를 피하기 