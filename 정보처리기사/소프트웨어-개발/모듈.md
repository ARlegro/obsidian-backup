모듈 = 하나의 기능을 하는 작은 코드의 집합?


### 개념 
전체 프로그램에서 어떠한 기능을 수행할 수 있는 실행 코드를 의미 


✔특징 
- **재사용 가능** 
- **자체 컴파일 가능**  
- ⭐모듈은 **독립성이 높을수록 좋다**. 이는 **결합도**와 **응집도**에 의해 측정된다.

> 재사용, 자체 컴파일, 독립성이 핵심 

### 결합도 ⭐⭐⭐⭐
- 서로 다른 두 모듈 간의 상호 의존도
- 낮을수록 독립성이 향상되어 유지보수 작업이 용이
- 자료 결합도가 설계 품질이 가장 좋다

#### 결합도의 6단계 ⭐**⭐**

> 낮은 순서 

`자 - 스 - 제 -외 - 공 - 내` 

##### ✅**1. 자료 결합도** **(가장 낮은)** **- 데이터 결합도** 

- 모듈 간의 인터페이스가 자료 요소로만 구성된 경우로, 다른 모듈에 영향을 주지 않는 결합도 
- 가장 바람직한 결합도로 결합도가 매우 약하다 
- 모듈 간의 내용을 전혀 알 필요가 없다
```java
public void process(String productName, int quantity) {
		System.out.println(productName + " x " + quantity);
}
```
- 의존 최소화, 변경에 강함


##### **스탬프 결합도** (두번째로 낮은)
- **두 모듈이 같은 자료 구조를 조회**하는 경우의 결합도
- 자료 구조의 어떠한 변화가 그것을 조회하는, 조회하지 않는 모듈까지도 영향을 미친다.
- ex. 객체, 배열, 레코드를 통째로 전달 
```java
public class Order {
    public String productName;
    public int quantity;
}

public class OrderService {
    public void process(Order order) {
        System.out.println(order.productName);
    }
}```
- 그래도 6단계 중 2번째로 결합도가 낮긴한데,
- productName만 필요한데 필요없는 객체를 받았다.
- 이는 구조 변경에 취약한 구조이다.

> [!INFO] 스탬프 결합도 vs 자료 결합도 쉽게 구분 
> 스탬프 결합도 ➡ `자료 구조`를 전달 
> 자료 결합도 ➡ `자료 요소`를 전달

##### **제어 결합도** 
- 한 모듈이 다른 모듈의 처리 흐름(제어)에 간섭 ex. boolean
```java
public void print(String msg, boolean upper) {
		if (upper) System.out.println(msg.toUpperCase());
		else System.out.println(msg.toLowerCase());
}
```

##### 외부 결합도 
- 두 모듈이 외부 시스템, 파일 포멧 등에 의존 
- 외부 시스템-파일 포맷이 바뀌면 모듈이 실패
- 즉, **외부 변화에 민감한 구조**이다.
```java
public void parse(String filePath) throws IOException {
		// 특정 형식의 외부 파일을 가정 (예: CSV)
		BufferedReader reader = new BufferedReader(new FileReader(filePath));
```


##### 공통 결합도 
- 전역 변수를 공유하는 예
- 어떤 모듈이 전역변수를 바꾸면 다른 모듈도 영향을 받는 구조 


##### 최악 : 내용 결합도 
한 모듈이 다른 모듈의 내부 구현, 자료를 직접 참조

```java
// 내부 필드에 직접 접근 (비추천)
class A {
    public int secret = 42;
}

class B {
    public void doSomething(A a) {
        a.secret = 999;  // A의 내부 구현에 직접 의존
    }
```
A의 구현이 바뀌면 B도 수정해야 됨
이는 유지보수에 최악 


### 응집도 ⭐⭐⭐

#### 개념 
- 얼마나 관련이 높은 요소끼리 모여있는지 
- 모듈이 독립적인 기능으로 구성됨의 정도를 의미 
- 응집도가 높다 ➡ 필요한 요소들로만 구성되었다는 의미
- 응집도가 낮다 ➡ 요소 간의 관련성이 적다

#### 단계 

> 높은 순서 - 높을수록 좋은 것 
##### **기능적 응집도** **(BEST)**
- 모듈 내부의 **모든 기능들이 한 문제와 연관되어** 수행되는 경우 
- 하나의 목적을 위해 메서드/모듈이 최적화 되어 있다
- 이는 확장/테스트/재사용 모두 굿 

##### **순차적 응집** 
- 모듈 내의 **한 기능의 작업의 결과가** **다른 기능의 작업의 입력 자료로 제공** 된다.
- 작업 흐름이 유기적으로 연결됨 
```java
void process(String jsonOrder){
		Order order = parse(jsonOrder);
		process(Order);
		send(Order)
}
```
- Order의 프로세스를 실행시키기 위해 parser 작업을 하는 

##### **교환적(통신적) 응집** 
- **같은 자료 구조를 사용**해서 처리하는 구조 
```java
public void process(User user){
		validate(User)
		save(User)
		notify(User)
}
```
- **공통 데이터로 연관성**을 확보 할 수 있다.

##### 절차적 응집 
- 순서상 연관된 작업이지만, **데이터는 공유하지 않는** 경우
- 데이터를 공유하지 않는다는 점에서 순차적 응집과 비교 
```java
public void processPayment() {
    verifyCard();
    updateLedger();
    sendReceipt();
}
```
- 교환적 응집과 비슷해보이지만 절차적 응집은 데이터도 공유 안하는 수준이다.

##### 시간적 응집 
- 같은 시점에 실행되는 작업들의 묶음 
```java
void init(){
	login()
	reset()
	create()
}
```
- 시점은 같지만, **논리적 관련은 적다**

##### 논리적 응집 
- 여러 기능 중 하나를 모듈 내에서 조건문으로 분기해서 처리 
- 이는 테스트에 어려움을 유발 

##### 우연적 응집 (Worst) ⭐
메서드 간 연관성 없는 것들을 같은 클래스에 넣어 놓은 예시 
재사용, 유지보수에 최악 


### 모듈 설계의 특징 

> 응집도는 강하게, 결합도는 약하게  -> 모듈의 독립성을 확보 

- 위의 기본 원칙을 지키며, 유지 보수를 수월하게 하기
- 모듈 간의 접속 관계를 분석하여 복잡도와 중복을 피하려 노력하기
- 계층적 자료 조직 제시 



### 모듈 vs 컴포넌트 


| 모듈 (클래스, 메서드)                 | 컴포넌트 (인터페이스의 구현체)                               |
| ----------------------------- | ----------------------------------------------- |
| 자신만으로 동작할 수 있는 명령의 집합         | 하나 이상의 기능을 수행하는 **독립적이고 재사용 가능한 부품** 모듈로 교체가 가능 |
| 내부 구현에 의존                     | 서비스, 역할 중심(소비자 입장)                              |
| 정의하지 않는 이상 바로 재활용 불가          | **인터페이스**를 통해서 연결된다                             |
| 독립성 낮다                        | 독립성 높음                                          |
| 실행가능하지만 특정 기능을 완벽하게 수행하기에는 무리 |                                                 |

**✅컴포넌트 예시 - 인터페이스**
```java
@Component
public class EmailSender implements NotificationService {
    public void send(String to, String msg) {     
    }
```


### 모듈 분할의 특징 
> 모듈 분할 이유 : 결합도 줄이고 응집도 높이기 위해 

설계의 질을 높이고 유지보수가 쉽게 해준다.
모듈 분할에 영향을 주는 설계
- 추상화
- 모듈화
- 은닉화
- 복잡도
- 시스템 구조 


### 공통 모듈 
#### 개념 및 효과 

각 시스템에서 공통으로 사용하는 기능을 묶어 하나의 공통된 모듈로 만들어 놓은 것
효과 
- 모듈의 재사용성을 높이고 
- 변경 시 일괄 변경 가능하게 한다

#### 명세 기법 
1. 정확성 
2. 명확성
3. 완전성
4. 일관성
5. 추적성 

#### 모듈 명세화 도구
- 흐름도 
- N-S도표
- 의사코드
- 의사 코드표
- 의사 결정 표 

> [!INFO] 시험에 나왔던 N-S 도표 
>- 순차-선택-반복을 사각형으로 도식화하여 논리적 기술에 중점을 둔 도형 표현 방법 
>- ![[Pasted image 20250505205250.png]]

>[!QUESTION] 문제
>**Q. 공통 모듈의 재사용 범위에 따른 분류가 아닌 것은**
>보기 1-컴포넌트 재사용 2-더미코드 재사용, 3-함수와 클래스 재사용, 4-애플리케이션 재사용
>A. 💡2번 더미코드!!!








